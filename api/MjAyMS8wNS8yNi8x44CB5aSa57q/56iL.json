{"title":"1、多线程","date":"2021-05-26T07:36:49.309Z","date_formatted":{"ll":"2021年5月26日","L":"2021/05/26","MM-DD":"05-26"},"link":"2021/05/26/1、多线程","updated":"2021-05-29T14:57:35.737Z","content":"<h1 id=\"1、概念\">1、概念<a title=\"#1、概念\" href=\"#1、概念\"></a></h1>\n<h2 id=\"多任务\">多任务<a title=\"#多任务\" href=\"#多任务\"></a></h2>\n<p>边吃饭边看手机，看起来是多个任务，但在同一时间里只做了一件事情</p>\n<h2 id=\"多线程\">多线程<a title=\"#多线程\" href=\"#多线程\"></a></h2>\n<p>原来只有一条车道，慢慢因为车多了，道路堵塞，效率降低，因此开辟了一条道路</p>\n<h2 id=\"普通方法和多线程\">普通方法和多线程<a title=\"#普通方法和多线程\" href=\"#普通方法和多线程\"></a></h2>\n<p><img src=\"https://gitee.com/xiaoyuxiu/blog-picture/raw/master/many1.jpg\" alt=\"img\" class=\"φcx\"></p>\n<h2 id=\"进程(process)和线程(thread)关系\">进程(process)和线程(Thread)关系<a title=\"#进程(process)和线程(thread)关系\" href=\"#进程(process)和线程(thread)关系\"></a></h2>\n<p>==一个进程可以有多个线程，==如视频中同时听到声音，看到图片，看弹幕等。==一个进程至少有一个线程，线程是CPU调度和执行的单位==</p>\n<p>很多多线程是模拟出来的，==真正的多线程是多个CPU，即多核，如服务器==</p>\n<p>==程序==：是指令和数据的有序集合，其本身没有，任何运行的含义，是一个==静态==的概念</p>\n<p>==进程==：是执行程序的一次执行过程，是一个==动态的概念，是系统资源分配==的单位</p>\n<h2 id=\"核心\">核心<a title=\"#核心\" href=\"#核心\"></a></h2>\n<p>1、线程是==独立的执行路径==</p>\n<p>2、在程序运行时，后台会有==多个路径，如主线程和gc线程==（即垃圾回收进程）</p>\n<p>3、==main（）称之为主线程，为系统的入口==，用于执行整个程序</p>\n<p>4、在一个进程中，如果开辟了多个线程，==线程的运行由调度器安排，调度器与操作系统相关，先后顺序是不能人为的干预的==</p>\n<p>5、对同一份资源操作时，会==存在资源抢夺问题，需要加入并发控制==</p>\n<p>6、==线程会带来额外的开销==，如Cpu调度时间，并发控制开销</p>\n<p>7、每个线程在自己的工作内存交互，==内存控制不当会造成数据不一致==</p>\n<h1 id=\"2、线程的创建\">2、线程的创建<a title=\"#2、线程的创建\" href=\"#2、线程的创建\"></a></h1>\n<p>Thread class    继承Thread类（重点）-------API</p>\n<p>Runnable 实现Runnable接口（重点）</p>\n<p>Callable  实现Callable接口（了解）</p>\n<h2 id=\"thread-class\">Thread class<a title=\"#thread-class\" href=\"#thread-class\"></a></h2>\n<p>==继承Thread类，重写run方法，创建对象，调用start（）==方法启动</p>\n<p>==start（）使得交替执行，没有先后顺序==</p>\n<h2 id=\"runnable\">Runnable<a title=\"#runnable\" href=\"#runnable\"></a></h2>\n<p>==一个类继承该接口，重写run方法，创建该类的对象，将Thread实例化并赋给它，再用start==</p>\n<h2 id=\"thread方法\">Thread方法<a title=\"#thread方法\" href=\"#thread方法\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Thread currentThread()</span><br></pre></td></tr></table></figure>\n<p>返回对当前正在执行的线程对象的引用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void sleep(long millis)</span><br><span class=\"line\">                  throws InterruptedException</span><br></pre></td></tr></table></figure>\n<p>使当前正在执行的线程以指定的毫秒数暂停(暂时停止执行)，具体取决于系统定时器和调度程序的精度和准确性。 线程不会丢失任何显示器的所有权。</p>\n<h2 id=\"小结\">小结<a title=\"#小结\" href=\"#小结\"></a></h2>\n<p>Thread：1、子类继承Thread类具备多线程能力</p>\n<p>​                 2、启动线程：子类对象.start()</p>\n<p>​                 3、==不建议：避免OOP单继承局限性==</p>\n<p>Runnable：1、实现Runnable具有多线程能力</p>\n<p>​                     2、启动线程：传入目标对象+Thread对象.start()</p>\n<p>​                     3、推荐：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</p>\n<h2 id=\"实现callable接口（了解）\">实现Callable接口（了解）<a title=\"#实现callable接口（了解）\" href=\"#实现callable接口（了解）\"></a></h2>\n<p>1、==实现Callable接口==，需要返回值类型</p>\n<p>2、==重写call方法==，需要抛出异常</p>\n<p>3、创建目标对象</p>\n<p>4、创建执行服务  ExecutorService ser=Executors.newFixedThreadPool(线程个数);</p>\n<p>5、提交执行：Future<Boolean>result1=ser.submit(线程名称)</Boolean></p>\n<p>6、获取结果：boolean r=result1.get()</p>\n<p>7、关闭服务：ser.shutdownNow();</p>\n<p><img src=\"https://gitee.com/xiaoyuxiu/blog-picture/raw/master/many1.jpg\" alt=\"img\" class=\"φcx\"></p>\n<h2 id=\"callable好处\">Callable好处<a title=\"#callable好处\" href=\"#callable好处\"></a></h2>\n<p>1、可以定义为返回值</p>\n<p>2、可以抛出异常</p>\n<h1 id=\"静态代理（进程的实现原理）\">静态代理（进程的实现原理）<a title=\"#静态代理（进程的实现原理）\" href=\"#静态代理（进程的实现原理）\"></a></h1>\n<p>你：真实角色</p>\n<p>婚庆公司：代理你，帮你处理结婚的事情</p>\n<p>结婚：实现结婚的接口</p>\n<h2 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h2>\n<p>真实对象和代理对象都要实现同一个接口，代理对象要先代理真实角色</p>\n<h3 id=\"好处\">好处<a title=\"#好处\" href=\"#好处\"></a></h3>\n<p>代理对象可以实现很多真实对象做不了的事情</p>\n<p>真实对象专注做自己的事情</p>\n<h1 id=\"lamda表达式-\">Lamda表达式-<a title=\"#lamda表达式-\" href=\"#lamda表达式-\"></a></h1>\n<h2 id=\"定义：\">定义：<a title=\"#定义：\" href=\"#定义：\"></a></h2>\n<p>==任何接口，如果只包含唯一一个抽象方法==，那么他就是一个函数式接口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Runable&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     public abstract void run（）；</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于函数式接口，我们可以通过lamda表达式来创建该接口的对象</p>\n<p>==最普通 静态内部类 局部内部类  匿名内部类  拉姆达类==</p>\n<h2 id=\"好处-1\">好处<a title=\"#好处-1\" href=\"#好处-1\"></a></h2>\n<p>避免匿名内部类定义过多</p>\n<p>其实质属于函数式编程的概念</p>\n<p>对象=()-&gt;{…}</p>\n<h2 id=\"==带有参数==\">==带有参数==<a title=\"#==带有参数==\" href=\"#==带有参数==\"></a></h2>\n<p>1、直接代入</p>\n<p>2、参数类型删去</p>\n<p>3、删去括号</p>\n<p>4、删去花括号，==但只能是一条语句==(以上可以一起执行)</p>\n<p>5、==有多个参数类型。去掉参数，用逗号隔开且用括号括====起来==</p>\n<h1 id=\"3、线程状态-\">3、线程状态-<a title=\"#3、线程状态-\" href=\"#3、线程状态-\"></a></h1>\n<p><img src=\"https://gitee.com/xiaoyuxiu/blog-picture/raw/master/many4.jpg\" alt=\"img\" class=\"φcx\"></p>\n<p>1000毫秒=1秒</p>\n<h2 id=\"停止线程\">停止线程<a title=\"#停止线程\" href=\"#停止线程\"></a></h2>\n<p>1、推荐线程自己停止下来</p>\n<p>2、建议使用一个标志位进行终止变量，当flag=false，则终止线程运行</p>\n<p>3、不推荐使用JDK提供的stop()、destroy()方法</p>\n<h4 id=\"步骤\">步骤<a title=\"#步骤\" href=\"#步骤\"></a></h4>\n<p>1、设置标识符</p>\n<p>2、设置一个公开方法停止线程，转换标识符</p>\n<p>3、调用stop方法切换标识符，让线程停止</p>\n<h2 id=\"线程休眠sleep\">线程休眠sleep<a title=\"#线程休眠sleep\" href=\"#线程休眠sleep\"></a></h2>\n<p>1、sleep指定当前线程阻塞的毫秒数</p>\n<p><em><strong>2、sleep存在异常interruptedException</strong></em></p>\n<p>3、sleep时间达到后线程进入就绪状态</p>\n<p>4、sleep可以模拟<em><strong>网络延时、倒计时</strong></em></p>\n<p>5、每一对象都有一把锁，sleep不会释放锁</p>\n<h2 id=\"线程礼让yield\">线程礼让yield<a title=\"#线程礼让yield\" href=\"#线程礼让yield\"></a></h2>\n<p>1、礼让线程，让当前正在执行的线程暂停，但不阻塞</p>\n<p>2、将线程从运行状态变为就绪状态</p>\n<p><strong>3、让cpu重新调度，礼让不一定成功，看CPU心情</strong></p>\n<h2 id=\"线程合并join\">线程合并join<a title=\"#线程合并join\" href=\"#线程合并join\"></a></h2>\n<p>1、join合并线程，待此线程执行完成后，在执行其他线程，其他线程阻塞</p>\n<p><strong>2、可以想象成插队</strong>，执行完插队的内容，在执行主线程</p>\n<h2 id=\"线程状态监测\">线程状态监测<a title=\"#线程状态监测\" href=\"#线程状态监测\"></a></h2>\n<p>NEW 尚未启动线程</p>\n<p>RUNNABLE 在Java虚拟机执行的线程处于此状态</p>\n<p>BLOOKED 被阻塞</p>\n<p>WAITING  正在等待另一个线程执行特定的动作处于此状态</p>\n<p>TIMED WAITING 正在等待另一个执行动作达到指定等待时间的线程处于此状态</p>\n<p>TERMINATED</p>\n<p>已退出的线程</p>\n<h2 id=\"线程优先级\">线程优先级<a title=\"#线程优先级\" href=\"#线程优先级\"></a></h2>\n<p>1、Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行</p>\n<p>2、线程的优先级用数字来表示，范围1到10</p>\n<p>Thread.MIN_PRIORITY=1</p>\n<p>Thread.MAX_PRIORITY=10</p>\n<p>Thread.NORN_PRIORITY=5</p>\n<p>3、使用以下方式改变或获取优先级</p>\n<p>getPority setPriority(int xxx)</p>\n<p><strong>4、从数字高的先执行</strong>（但还是得看CPU调度）</p>\n<h2 id=\"守护(daemon)线程\">守护(daemon)线程<a title=\"#守护(daemon)线程\" href=\"#守护(daemon)线程\"></a></h2>\n<p>1、线程分为<strong>用户线程和守护线程</strong></p>\n<p>2、虚拟机必须确保用户线程执行完毕 main</p>\n<p>3、虚拟机不用等待守护线程执行完毕   gc</p>\n<p>4、true为用户线程 false为守护线程</p>\n<p>如：后台记录操作日志，监控内存，垃圾回收</p>\n<h1 id=\"4、线程同步机制\">4、线程同步机制<a title=\"#4、线程同步机制\" href=\"#4、线程同步机制\"></a></h1>\n<p>==并发：同一个对象被多个线程同时操作==  例如：两个银行同时取钱</p>\n<p>现实生活中，遇到同一个戏院多个人想同时使用，比如食堂排队，每个人先吃饭，<strong>最简单的方式:排队</strong></p>\n<p>处理多个线程问题，<strong>多个线程访问同一个对象时</strong>，并且某些线程还想修改这个对象，这时候我们就需要线程同步，线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程在使用</p>\n<p>形成条件：队列+==锁==</p>\n<p>由于同一进程的多个线程同时共享同一块存储空间，在带来方便的同时，也也带来访问冲突问题。为了保证数据在方法中被访问时的正确性，在访问时加入锁机制 ==synchronized== ，==<strong>当一个线程获得对象的锁。独占资源。其他线程笔其他对象必须等待，使用后释放锁即可</strong>，但存在以下问题：</p>\n<p>1、一个线程持有索会导致其他所有需要此锁的线程挂起</p>\n<p>2、在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延迟，<strong>引起性能问题</strong></p>\n<p>3、如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，<strong>引起性能问题</strong>。比如：上大号和小号，性能低大号上厕所，小号性能高会等待的久</p>\n<h2 id=\"同步synchronized\">同步synchronized<a title=\"#同步synchronized\" href=\"#同步synchronized\"></a></h2>\n<p>synchronized方法和synchronized块</p>\n<h3 id=\"同步方法\">同步方法<a title=\"#同步方法\" href=\"#同步方法\"></a></h3>\n<p><strong>public synchronized void method(int  args){ }</strong></p>\n<p>synchronized方法<strong>控制对象的访问</strong>，每个对象对应一把锁，每个==synchronized==**方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞。方法一旦调用，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程。**缺陷：==将一个大的方法声明为synchronized将会影响效率==</p>\n<h3 id=\"同步块\">同步块<a title=\"#同步块\" href=\"#同步块\"></a></h3>\n<p><strong>synchronized（Obj）{}</strong></p>\n<p>==Obj称为同步监视器，锁变化的量==</p>\n<p>**Obi可以是任何对象，**但是推荐使用共享资源作为同步监视器</p>\n<p>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class【反射中讲解】</p>\n<p>同步监视器的执行过程：</p>\n<p>1、第一个线程访问，锁定同步监视器，执行其中代码</p>\n<p>2、第二个线程访问，发现同步监视器被锁定，无法访问</p>\n<p>3、第一个线程访问，解锁同步监视器</p>\n<p>4、第二个线程访问，发现同步监视器没有被锁定，然后锁定并访问</p>\n<h2 id=\"juc安全集合\">juc安全集合<a title=\"#juc安全集合\" href=\"#juc安全集合\"></a></h2>\n<p>==CopyOnWriteArrayList==所建立的对象是安全的</p>\n<h1 id=\"5、死锁\">5、死锁<a title=\"#5、死锁\" href=\"#5、死锁\"></a></h1>\n<p>多个线程各自站有一些共享资源，并且互相等待其他线程占有的资源才能运行，<strong>而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，==某一个同步块同时拥有”两个以上对象的锁“时，就可能会发生”死锁“问题==</strong></p>\n<p>例如：拿了这个锁，但还想要另一个所，但一个人只能有一个锁</p>\n<h2 id=\"产生死锁的四个必要条件\">产生死锁的四个必要条件<a title=\"#产生死锁的四个必要条件\" href=\"#产生死锁的四个必要条件\"></a></h2>\n<p>1、互斥条件：一个资源每次只能被一个进程使用</p>\n<p>2、请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放</p>\n<p>3、不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺、</p>\n<p>4、循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系</p>\n<p><strong>==只要想办法破其中的任意一个或多个条件就可以避免死锁发生==</strong></p>\n<h1 id=\"6、lock锁\">6、Lock锁<a title=\"#6、lock锁\" href=\"#6、lock锁\"></a></h1>\n<p>1、通过显示定义同步锁对象来实现同步，同步锁使用了Lock对象充当</p>\n<p>2、java.util.concurrent.locks.Lock接口是<strong>控制多个线程对共享资源进行访问的工具，锁提供了对共享资源空间的独占访问，每次只能有一个线程对Lock对象加锁</strong>，线程开始访问共享对象之前先获的Lock对象</p>\n<p>3、<strong>ReentrantLock类实现Lock</strong>，<strong>它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的时ReentrantLock，可以显示加锁、释放锁</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class A&#123;</span><br><span class=\"line\">   private final ReentrantLock lock&#x3D;new ReentratrLock();</span><br><span class=\"line\">   public void m()&#123;</span><br><span class=\"line\">   \t lock.lock();</span><br><span class=\"line\">     try&#123;</span><br><span class=\"line\">     </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     finally&#123;</span><br><span class=\"line\">       lock.unlock();</span><br><span class=\"line\">       &#x2F;&#x2F;如果同步代码块有异常，将unlock（）写入finally语句块</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"synchronized和lock的对比\">Synchronized和Lock的对比<a title=\"#synchronized和lock的对比\" href=\"#synchronized和lock的对比\"></a></h1>\n<p>==1、<strong>Lock是显示锁(手动开启和关闭锁)，synchronized是隐式锁，出了作用域自动释放</strong>==</p>\n<p>2、Lock只有代码块锁，synchronized有代码块锁和方法锁</p>\n<p>3、使用Lock锁，JVM将花费较少的时间调度线程，性能更好，并且具有更好的拓展性</p>\n<p>优先使用顺序：Lock&gt;同步代码块（已经进入了方法体，分配了相应资源）&gt;同步方法(在方法体之外)</p>\n<h1 id=\"7、线程通信\">7、线程通信<a title=\"#7、线程通信\" href=\"#7、线程通信\"></a></h1>\n<p>分析：这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件</p>\n<p>1、对于生产者，没有生产产品之前，要通知消费者等待，而生产了产品之后，又需要马上通知消费者消费</p>\n<p>2、对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费</p>\n<p>==3、在生产者消费者问题中，仅有synchronized是不够的==</p>\n<p>​      ==synchronized可阻止并发更新同一个共享资源，实现了同步==</p>\n<p>​      ==synchronized不能用来实现不同线程之间的消息传递(通信)==</p>\n<h2 id=\"方法\">方法<a title=\"#方法\" href=\"#方法\"></a></h2>\n<p>wait() 表示线程会一直等待，知道其他线程通知，与sleep不同，会释放锁</p>\n<p>wait(long times)指定等待的毫秒数</p>\n<p>notify() 唤醒一个处于等待状态的线程</p>\n<p>notifyAll() 唤醒同一个对象上所有调用wait() 方法的线程，优先级别高的线程优先调查</p>\n<p>均为Object类的方法，==都只能在同步方法或者同步代码块中使用==，否则会抛出异常IllegalMonitorStateException</p>\n<h2 id=\"解决\">解决<a title=\"#解决\" href=\"#解决\"></a></h2>\n<h3 id=\"（1）并发协作模型”生产者/消费者模式“-&gt;管程法\">（1）并发协作模型”生产者/消费者模式“-&gt;管程法<a title=\"#（1）并发协作模型”生产者/消费者模式“-&gt;管程法\" href=\"#（1）并发协作模型”生产者/消费者模式“-&gt;管程法\"></a></h3>\n<p>生产者：负责生产数据的模块(可能是方法，对象，线程，进程)</p>\n<p>消费者：负责处理数据的模块(可能是方法，对象，线程，进程)</p>\n<p>缓冲区：消费者不能直接使用生产者的数据，它们之间有个”缓冲区“</p>\n<p>==生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据==</p>\n<h3 id=\"（2）并发协作模型”生产者/消费者模式“-&gt;信号灯法\">（2）并发协作模型”生产者/消费者模式“-&gt;信号灯法<a title=\"#（2）并发协作模型”生产者/消费者模式“-&gt;信号灯法\" href=\"#（2）并发协作模型”生产者/消费者模式“-&gt;信号灯法\"></a></h3>\n<p>类似于”停止线程“</p>\n<h1 id=\"注意\">注意<a title=\"#注意\" href=\"#注意\"></a></h1>\n<p>sleep（） wait（）有try catch</p>\n<h1 id=\"8、线程池\">8、线程池<a title=\"#8、线程池\" href=\"#8、线程池\"></a></h1>\n<p>背景：经常创建和销毁，使用量特别大，比如出现并发情况下的线程，对性能影响很大</p>\n<p>思路：提前创建好多个线程，放入线程池中，使用是直接获取，使用完放回池子中，可以避免频繁创建销毁、实现重复利用，类似交通工具</p>\n<p>好处：提高响应速度，降低资源耗损，便于线程管理</p>\n<p>方法：corePoolSize：核心池的大小</p>\n<p>​            maximumPoolSize：最大线程数</p>\n<p>​             keepAliveTime：线程没有任务时最多保持多长时间会终止</p>\n<p>ExecutorService：真正线程池接口</p>\n<p>​                                 常见子类；void excute(Runnable command)——执</p>\n<p>​                                                    行命令，没有返回值</p>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t<T>Future<T>submit(Callable<T>task)——</T></T></T></p>\n<p>​                                                    执行命令，有返回值</p>\n<p>​                                                    void  shutdown()——关闭连接池</p>\n<p>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</p>\n","next":{"title":"Typora常用快捷键","link":"2021/05/22/Typora常用快捷键"},"plink":"http://example.com/2021/05/26/1、多线程/","toc":[{"id":"1、概念","title":"1、概念","index":"1","children":[{"id":"多任务","title":"多任务","index":"1.1"},{"id":"多线程","title":"多线程","index":"1.2"},{"id":"普通方法和多线程","title":"普通方法和多线程","index":"1.3"},{"id":"进程(process)和线程(thread)关系","title":"进程(process)和线程(Thread)关系","index":"1.4"},{"id":"核心","title":"核心","index":"1.5"}]},{"id":"2、线程的创建","title":"2、线程的创建","index":"2","children":[{"id":"thread-class","title":"Thread class","index":"2.1"},{"id":"runnable","title":"Runnable","index":"2.2"},{"id":"thread方法","title":"Thread方法","index":"2.3"},{"id":"小结","title":"小结","index":"2.4"},{"id":"实现callable接口（了解）","title":"实现Callable接口（了解）","index":"2.5"},{"id":"callable好处","title":"Callable好处","index":"2.6"}]},{"id":"静态代理（进程的实现原理）","title":"静态代理（进程的实现原理）","index":"3","children":[{"id":"总结","title":"总结","index":"3.1","children":[{"id":"好处","title":"好处","index":"3.1.1"}]}]},{"id":"lamda表达式-","title":"Lamda表达式-","index":"4","children":[{"id":"定义：","title":"定义：","index":"4.1"},{"id":"好处-1","title":"好处","index":"4.2"},{"id":"==带有参数==","title":"&#x3D;&#x3D;带有参数&#x3D;&#x3D;","index":"4.3"}]},{"id":"3、线程状态-","title":"3、线程状态-","index":"5","children":[{"id":"停止线程","title":"停止线程","index":"5.1"},{"id":"线程休眠sleep","title":"线程休眠sleep","index":"5.2"},{"id":"线程礼让yield","title":"线程礼让yield","index":"5.3"},{"id":"线程合并join","title":"线程合并join","index":"5.4"},{"id":"线程状态监测","title":"线程状态监测","index":"5.5"},{"id":"线程优先级","title":"线程优先级","index":"5.6"},{"id":"守护(daemon)线程","title":"守护(daemon)线程","index":"5.7"}]},{"id":"4、线程同步机制","title":"4、线程同步机制","index":"6","children":[{"id":"同步synchronized","title":"同步synchronized","index":"6.1","children":[{"id":"同步方法","title":"同步方法","index":"6.1.1"},{"id":"同步块","title":"同步块","index":"6.1.2"}]},{"id":"juc安全集合","title":"juc安全集合","index":"6.2"}]},{"id":"5、死锁","title":"5、死锁","index":"7","children":[{"id":"产生死锁的四个必要条件","title":"产生死锁的四个必要条件","index":"7.1"}]},{"id":"6、lock锁","title":"6、Lock锁","index":"8"},{"id":"synchronized和lock的对比","title":"Synchronized和Lock的对比","index":"9"},{"id":"7、线程通信","title":"7、线程通信","index":"10","children":[{"id":"方法","title":"方法","index":"10.1"},{"id":"解决","title":"解决","index":"10.2","children":[{"id":"（1）并发协作模型”生产者/消费者模式“-&gt;管程法","title":"（1）并发协作模型”生产者&#x2F;消费者模式“-&gt;管程法","index":"10.2.1"},{"id":"（2）并发协作模型”生产者/消费者模式“-&gt;信号灯法","title":"（2）并发协作模型”生产者&#x2F;消费者模式“-&gt;信号灯法","index":"10.2.2"}]}]},{"id":"注意","title":"注意","index":"11"},{"id":"8、线程池","title":"8、线程池","index":"12"}],"copyright":{"author":"John Doe","license":"Attribution-NonCommercial-NoDerivatives 4.0 International"}}