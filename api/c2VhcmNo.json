[{"title":"什么是注解","date":"2021-05-22T02:35:45.258Z","date_formatted":{"ll":"2021年5月22日","L":"2021/05/22","MM-DD":"05-22"},"updated":"2021-05-22T02:32:43.836Z","content":"什么是注解\n注解：java.Annotation    注释：commat\n作用：不是程序本身，可以对程序作出解释；可以被其他程序（如编译器）读取\n格式：注解以**“@注释名**”在代码中存在的，还可以添加一些参数值，例如：@SuppressWarnings(value=“uncheck”)\n适用范围 ：可以附加在package、class、method、field等上面，相当于给他们添加了额外的辅助信息，通过反射编程实现对这些元数据的访问\n注解分类：内置注解、元注解、自定义注解\n内置注解\n@Override定义在Java.lang.Override中，此注释只使用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明\n@Deprecated定义在java.lang.Deprecated，此注释可以用于修饰方法、属性、类，通常因为他很危险或有更好的选择，不推荐使用\n@SuppressWarnings定义在java.lang.SuppressWarnings中，用来抑制编译时的警告信息，需要添加一个参数才能正确使用\n@SuppressWarnings(“uncheck”)    @SuppressWarnings(value={“uncheck”，“deprecation”)\n1234567891011121314151617181920212223242526package Annotation;import java.util.ArrayList;import java.util.List;&#x2F;&#x2F;测试学习什么是注解public class Demoone &#123;    @Override  &#x2F;&#x2F;重写方法的注解    public String toString() &#123;        return super.toString();    &#125;    @Deprecated  &#x2F;&#x2F;不推荐使用。有更好的方法    public static void test()&#123;        System.out.println(&quot;women&quot;);    &#125;    @SuppressWarnings(&quot;all&quot;)    public  void test01()&#123;        List list &#x3D; new ArrayList();    &#125;    public static void main(String[] args)&#123;        test();    &#125;&#125;\n元注解\n作用：负责注解其他注释，定义了4个标准的mata-annotation类型，他们被\n用来提供对其他annotation类型做说明\n@Target：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）\n@Retention：表示需要在上面级别保存该注释信息，用于描述注解的生命周期（SOURCE&lt;CLASS&lt;RUNTIME）\n@Document：说明该注解被包含在javadoc中\n@Inherited：说明子类可以继承父类中的该注解\n123456789101112131415161718package Annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;public class Demotwo &#123;&#125;&#x2F;&#x2F;自定义注解,value可以省略@Target(value&#x3D; ElementType.METHOD)&#x2F;&#x2F;表示注解可以用整改什么地方@Retention(value&#x3D; RetentionPolicy.RUNTIME)&#x2F;&#x2F;表示注解在什么地方有效runtime&gt;class&gt;source@interface MyAnnotation&#123;&#125;\n12345678910111213141516171819202122232425package Annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;public class Demothree &#123;    @MyAnnnotation2(school &#x3D; &quot;西北大学，咳咳咳大学&quot;)    &#x2F;&#x2F;基给予参数    public void test()&#123;    &#125;&#125;&#x2F;&#x2F;自定义注解@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnnotation2&#123;    &#x2F;&#x2F;注解参数：参数类型 参数名()    String name() default &quot;&quot;;    &#x2F;&#x2F;有默认值则不用给注解参数    int age() default -1;    &#x2F;&#x2F;默认值位-1 代表参数不存在    String[] school();&#125;\n","plink":"http://example.com/2021/05/22/什么是注解/"},{"title":"1、概述","date":"2021-05-17T01:55:53.624Z","date_formatted":{"ll":"2021年5月17日","L":"2021/05/17","MM-DD":"05-17"},"updated":"2021-05-16T06:22:42.483Z","content":"1、概述\n地球村：你在西安打电话，美国可以收到\n打电话：–连接–接了–通话  ==TCP==\n发短信：–发了就完事--  ==UDP==\n\n**计算机网络：**将==地理位置不同==的具有独立功能的==多台计算机及其外部设备==，通过通信线路连接起来，在网络操作系统，网络管理软件及==网络通信协议==的管理和协调下，实现==资源共享==和信息传递的计算机系统。\n**网络编程的目的：**传播交流信息、数据交换、通信\n想要达到效果需要什么：\n1、如何准确定义网络上的主机：主机号、端口号、定位计算机某个资源\n2、找到了主机，如何传输数据\n注意\njavaweb：网页编程 B/S\n网络编程：TCP/IP   C/S  客户端\n2、网络通信的要素\n人工智能：智能汽车——工厂、人少，不能上市（伦理）！\n实现网络通信：通信双方的地址–ip+端口号   Eg：192.268.16.124：5900\n规则：网络通信的协议   http、ftp、smtp、tcp、udp\nTCP/IP模型，传输层所学重点\n\n小结\n1、网络编程中主要的两个问题\n​      (1)如何准确定位网络上的一台或者多台主机\n​      (2)找到主机之后如何进行通信\n![img](file:///C:\\Users\\Administrator\\AppData\\Roaming\\Tencent\\Users\\1917429455\\QQ\\WinTemp\\RichOle\\C9VGX_[SD9Z%RBT{PGVB}00.png)\n2、网络编程的要素\n（1）ip和端口号\n（2）网络通信协议\n3、万物皆对象，有相关的类没有就创建\n3、IP\nip地址：InetAddress\n(1)唯一定位一台网络上计算机\n(2)127.0.0.1:本机上的ip\n(3)ip地址的分类：\n通过ip地址分配（ipv4/ipv6）\n–==ipv4==：127.0.0.1，由四个字节组成，0~255\n–==ipv6==： fe80::60e6:343f:6d9b:49f7%18，128位，8个无符号整数，abcd\n公网（互联网使用）-私网（局域网使用）\n1、192.168.xx.xxx  专门给组织内部使用\n2、ABCD类 地址（阿里笔试）\n域名的诞生—记忆ip的问题\n1234567891011121314151617181920212223242526272829303132import java.net.InetAddress;import java.net.UnknownHostException;public class TestInetAddress &#123;&#x2F;&#x2F;测试ip\tpublic static void main(String[] args) &#123;\t\ttry&#123;\t\t\t&#x2F;&#x2F;查询本机地址\t\t\tInetAddress inet1&#x3D;InetAddress.getByName(&quot;127.0.0.1&quot;);\t\t\tSystem.out.println(inet1);\t\t\tInetAddress inet2&#x3D;InetAddress.getByName(&quot;localhost&quot;);\t\t\tSystem.out.println(inet2);\t\t\tInetAddress inet3&#x3D;InetAddress.getLocalHost();\t\t\tSystem.out.println(inet3);\t\t\t\t\t\t&#x2F;&#x2F;查询网站ip地址\t\t\tInetAddress inet4&#x3D;InetAddress.getByName(&quot;www.baidu.com&quot;);\t\t\tSystem.out.println(inet4);\t\t\t\t\t\t&#x2F;&#x2F;常用方法\t\t\t&#x2F;&#x2F;System.out.println(inet4.getAddress());\t\t\tSystem.out.println(inet4.getCanonicalHostName());\t\t\tSystem.out.println(inet4.getHostAddress());\t\t\tSystem.out.println(inet4.getHostName());\t\t&#125;catch(UnknownHostException e)&#123;\t\t\te.printStackTrace();\t\t&#125;\t\t\t\t&#125;\t&#125;\n4、端口\n表示计算机上一个程序的进程\nEg：每栋楼是一个ip，每个居民端口\n（1)==不同的进程有不同的端口号，用来区分软件==，ip区分地址，可以有\n​       0~655354个软件\n(2)分为TCP和UDP，==单个协议下面端口号不能冲突==  Eg：tcp=80，udp=80\n​     是错的\n端口分类：（1）公有端口 0~1023\n​                    http80、 https 443 、ftp21 、telent23\n​\t\t\t\t\t相当于https://1/=heeps://1:443/\n​                   （2）程序注册端口 2014~49151   分配用户或程序\n​                       Tomcat8080、MySql3306、Oracle1521\n​                   （3）动态私有：49152~65535\n12341 netstat -ano #查看所有的端口2 netstat -ano|findstr &quot;5900&quot; #查看指定的端口号3 tasklisdt|findstr &quot;8787&quot; #查看指定端口的远程4 ctrl+shift+esc #打开任务管理器\n1234567891011import java.net.InetSocketAddress;public class TestInetStockAddress &#123;\tpublic static void main(String []args)&#123;\t\tInetSocketAddress a&#x3D;new InetSocketAddress(&quot;222&quot;,0000);\t\tSystem.out.println(a);\t\tSystem.out.println(a.getAddress());\t\tSystem.out.println(a.getPort());\t&#125;&#125;\n5、通信协议\n协议：约定，就好比上课约定好用普通话，进行交流\n网络通信协议：速率、传输码率、代码结构、传输控制\n大事化小：分层！\nTCP/IP协议-实际上位一组协议\n重要：（1）TCP：用户传输协议\n​            （2）UDP：用户数据报协议\n出名的协议：（1）TCP：用户传输协议\n​                       （2） IP：网络互连协议\nTCP、UDP对比\nTCP：打电话\n（1）连接、稳定\n（2）三次握手、四次挥手\n1234567891、最少需要三次，保证稳定链接A:你干嘛B：吃饭A：我也要2、最少需要四次，保证断开A：我要走了B：我真的要走吗?B：我真的真的真的要走吗？A：真的要走！\n（3）客户端、服务端\n（4）传输完成、释放连接、效率低\nUDP：发短信\n（1）不连接、不稳定\n（2）客户端、服务端：没有明确的界限\n（3）不管有没有准备好，都可以发送给你，类似于导弹\n6、TCP\n客户端：在web中是以request对象存在的,发送请求给服务器端处理.\n服务端 ：顾名思义是服务的,客户端发送的请求交给服务器端处理,是以response对象存在,服务器端处理完毕后反馈给客户端。\n一般我们访问网站,都是==客户端(浏览器、app)发出请求==,然后==对方服务器端(sina,sohu)响应,==结果就是返回了页面路径给我们,我们再根据路径看到了网页。\n1又叫主从式架构，简称C&#x2F;S结构，是一种网络架构，它把客户端 (Client) (通常是一个采用图形用户界面的程序)与服务器 (Server) 区分开来。每一个客户端软件的实例都可以向一个服务器或应用程序服务器发出请求。有很多不同类型的服务器，例如文件服务器、终端服务器和邮件服务器等。虽然它们的存在的目的不一样，但基本构架是一样的。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.InetAddress;import java.net.ServerSocket;import java.net.Socket;import java.net.UnknownHostException;\t&#x2F;&#x2F;服务器端public class TopClimtDemo01 &#123;\tpublic static void main(String[] args) &#123;\t\tServerSocket s&#x3D;null;\t\tSocket a&#x3D;null;\t\tInputStream is&#x3D;null;\t\tByteArrayOutputStream baos&#x3D;null;\t\ttry&#123;\t\t\t&#x2F;&#x2F;有一个服务器地址\t\t    s&#x3D;new ServerSocket(7888);&#x2F;&#x2F;创建绑定到指定端口的服务器套接字。\t\t\t&#x2F;&#x2F;等待客户端连接侦听与此套接字建立的连接并接受它。 该方法将阻塞，直到建立连接为止。\t\t\ta&#x3D;s.accept();            &#x2F;*创建一个新的Socket，如果有安全管理器，则使用s.getInetAddress（）            getHostAddress（）和s.getPort（）作为其参数来调用安全管理器的checkAccept方             法，以确保允许该操作，这可能会导致 SecurityException。*&#x2F;\t\t\t&#x2F;&#x2F;读取客户端信息\t\t    is&#x3D;a.getInputStream();\t\t\t&#x2F;&#x2F;管道流\t\t\tbaos&#x3D;new ByteArrayOutputStream();\t\t\tbyte[] b&#x3D;new byte[1024];\t\t\tint len;\t\t\twhile((len&#x3D;is.read(b))!&#x3D;-1)&#123;\t\t\t\tbaos.write(b,0,len);\t\t\t&#125;\t\t\tSystem.out.println(baos.toString());\t\t\t&#125;catch(IOException e)&#123;\t\t\t\te.printStackTrace();\t\t\t&#125;finally&#123;\t\t\t\tif(baos!&#x3D;null)&#123;\t\t\t\t  try &#123;\t\t\t\t\tbaos.close();\t\t\t\t  &#125; catch (IOException e) &#123;\t\t\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\tif(is!&#x3D;null)&#123;\t\t\t\ttry &#123;\t\t\t\t\tis.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\tif(s!&#x3D;null)&#123;\t\t\t\ttry &#123;\t\t\t\t\ts.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\tif(a!&#x3D;null)&#123;\t\t\t\ttry &#123;\t\t\t\t\ta.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t\t&#125;&#125;&#x2F;&#x2F;客户端public class TopServeDemo01 &#123;\tpublic static void main(String []args)&#123;\t\tSocket a&#x3D;null;\t\tOutputStream w&#x3D;null;\t\ttry&#123;\t\t\t&#x2F;&#x2F;知道服务器的地址\t\t\tInetAddress sIP&#x3D;InetAddress.getByName(&quot;127.0.0.1&quot;);\t\t\t&#x2F;&#x2F;知道端口号\t\t\tint port&#x3D;7888;\t\t\t&#x2F;&#x2F;创建一个socket的连接\t\t\ta&#x3D;new Socket(sIP,port);\t\t\t&#x2F;&#x2F;发送消息  IO流\t\t\tw&#x3D;a.getOutputStream();\t\t\tw.write(&quot;你好,欢迎来&quot;.getBytes());\t\t&#125;\t\tcatch(Exception e)&#123;\t\t\te.printStackTrace();\t\t&#125;finally&#123;\t\t\t&#x2F;&#x2F;关闭资源\t\t\tif(w!&#x3D;null)&#123;\t\t\ttry &#123;\t\t\t\tw.close();\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\t&#125;\t\t\tif(a!&#x3D;null)&#123;\t\t\ttry &#123;\t\t\t\ta.close();\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n7、文件上传\n把文件变成流 读出来\nlocalhost、127.0.0.1 和 本机IP之间的区别：\n1、localhost等于127.0.0.1，不过localhost是域名，127.0.0.1是IP地址。\n2、localhost和127.0.0，不需要联网，都是本机访问。\n3、本机IP需要联网，本机IP是本机或外部访问， 本机 IP 就是本机对外放开访问的IP地址，这个网址就是与物理网卡绑定的IP地址。\n8、Tomacat\n服务器：自定义S\n​               Tomcat服务器S\n客户端：自定义c\n​                浏览器B\n9、UDP\n发短信：不用连接，需要知道对方地址\nDatagramPacket   数据发送包相当于信件   DatagramSocket 接受包\n1234567891011121314151617181920212223242526272829303132333435363738394041package Demo03;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.SocketException;&#x2F;&#x2F;接收端public class UDPClimeDemo03 &#123;\tpublic static void main(String []args) throws IOException&#123;\t\t&#x2F;&#x2F;开放端口\t\tDatagramSocket so&#x3D;new DatagramSocket(2022);\t\tbyte []buffer&#x3D;new byte[1024];\t\tDatagramPacket pocket&#x3D;new DatagramPacket(buffer,0,buffer.length);\t\tso.receive(pocket);\t\tSystem.out.println(pocket.getAddress().getHostAddress());\t\tSystem.out.println(new String(pocket.getData(),0,pocket.getLength()));\t\t&#x2F;&#x2F;关闭连接\t\tso.close();\t&#125;&#125;public class UdpServeDemo03 &#123;&#x2F;&#x2F;发送端\tpublic static void main(String[] args) throws Exception &#123;\t\t&#x2F;&#x2F;1、建立一个Socket\t\tDatagramSocket socket&#x3D;new DatagramSocket();\t\t&#x2F;&#x2F;2、建个包\t\tString m&#x3D;&quot;你好啊,服务器&quot;;\t\tInetAddress localhost&#x3D;InetAddress.getByName(&quot;localhost&quot;);\t\tint port&#x3D;2022;\t\t&#x2F;&#x2F;数据、数据的长度起始要发送给谁\t\tDatagramPacket pocket&#x3D;new DatagramPacket(m.getBytes(),0,m.getBytes().length,localhost,port);\t\t&#x2F;&#x2F;3、发送包\t\tsocket.send(pocket);\t\t&#x2F;&#x2F;4、关闭流\t\tsocket.close();\t&#125;&#125;\n123456789101112131415161718package Demo06;import java.net.MalformedURLException;import java.net.URL;public class Url &#123;\tpublic static void main(String[] args) throws MalformedURLException &#123;\t\tURL url&#x3D;new URL(&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;hellowworld&#x2F;indextsjsajads&quot;);\t\tSystem.out.println(url.getFile());\t\tSystem.out.println(url.getHost());\t\tSystem.out.println(url.getPath());\t\tSystem.out.println(url.getQuery());\t\tSystem.out.println(url.getProtocol());\t&#125;&#125;\n","plink":"http://example.com/2021/05/17/1、概述/"},{"title":"多线程","date":"2021-05-16T07:15:27.872Z","date_formatted":{"ll":"2021年5月16日","L":"2021/05/16","MM-DD":"05-16"},"updated":"2021-05-16T07:28:17.588Z","content":"1、概念\n多任务\n边吃饭边看手机，看起来是多个任务，但在同一时间里只做了一件事情\n多线程\n原来只有一条车道，慢慢因为车多了，道路堵塞，效率降低，因此开辟了一条道路\n普通方法和多线程\n\n进程（process）和线程（Thread）关系\n==一个进程可以有多个线程，==如视频中同时听到声音，看到图片，看弹幕等。==一个进程至少有一个线程，线程是CPU调度和执行的单位==\n很多多线程是模拟出来的，==真正的多线程是多个CPU，即多核，如服务器==\n==程序==：是指令和数据的有序集合，其本身没有，任何运行的含义，是一个==静态==的概念\n==进程==：是执行程序的一次执行过程，是一个==动态的概念，是系统资源分配==的单位\n核心\n1、线程是==独立的执行路径==\n2、在程序运行时，后台会有==多个路径，如主线程和gc线程==（即垃圾回收进程）\n3、==main（）称之为主线程，为系统的入口==，用于执行整个程序\n4、在一个进程中，如果开辟了多个线程，==线程的运行由调度器安排，调度器与操作系统相关，先后顺序是不能人为的干预的==\n5、对同一份资源操作时，会==存在资源抢夺问题，需要加入并发控制==\n6、==线程会带来额外的开销==，如Cpu调度时间，并发控制开销\n7、每个线程在自己的工作内存交互，==内存控制不当会造成数据不一致==\n2、线程的创建\nThread class    继承Thread类（重点）-------API\nRunnable 实现Runnable接口（重点）\nCallable  实现Callable接口（了解）\nThread class\n==继承Thread类，重写run方法，创建对象，调用start（）==方法启动\n==start（）使得交替执行，没有先后顺序==\nRunnable\n==一个类继承该接口，重写run方法，创建该类的对象，将Thread实例化并赋给它，再用start==\nThread方法\n1public static Thread currentThread()\n返回对当前正在执行的线程对象的引用。\n12public static void sleep(long millis)                  throws InterruptedException\n使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。 线程不会丢失任何显示器的所有权。\n小结\nThread：1、子类继承Thread类具备多线程能力\n​                 2、启动线程：子类对象.start（）\n​                 3、==不建议：避免OOP单继承局限性==\nRunnable：1、实现Runnable具有多线程能力\n​                     2、启动线程：传入目标对象+Thread对象.start（）\n​                     3、推荐：避免单继承局限性，灵活方便，方便同一个对象被多\n​                           个线程使用\n实现Callable接口（了解）\n1、==实现Callable接口==，需要返回值类型\n2、==重写call方法==，需要抛出异常\n3、创建目标对象\n4、创建执行服务  ExecutorService ser=Executors.newFixedThreadPool(线程个数);\n5、提交执行：Futureresult1=ser.submit（线程名称）\n6、获取结果：boolean r=result1.get（）\n7、关闭服务：ser.shutdownNow();\n\nCallable好处\n1、可以定义为返回值\n2、可以抛出异常\n静态代理（进程的实现原理）\n你：真实角色\n婚庆公司：代理你，帮你处理结婚的事情\n结婚：实现结婚的接口\n总结\n真实对象和代理对象都要实现同一个接口，代理对象要先代理真实角色\n好处\n代理对象可以实现很多真实对象做不了的事情\n真实对象专注做自己的事情\nLamda表达式\n定义：\n==任何接口，如果只包含唯一一个抽象方法==，那么他就是一个函数式接口\n12345public interface Runable&#123;     public abstract void run（）；&#125;\n对于函数式接口，我们可以通过lamda表达式来创建该接口的对象\n==最普通 静态内部类 局部内部类  匿名内部类  拉姆达类==\n好处\n避免匿名内部类定义过多\n其实质属于函数式编程的概念\n对象=（）-&gt;{…}\n==带有参数==\n1、直接代入\n2、参数类型删去\n3、删去括号\n4、删去花括号，==但只能是一条语句==（以上可以一起执行）\n5、==有多个参数类型。去掉参数，用逗号隔开且用括号括====起来==\n3、线程状态-\n\n1000毫秒=1秒\n停止线程\n1、推荐线程自己停止下来\n2、建议使用一个标志位进行终止变量，当flag=false，则终止线程运行\n3、不推荐使用JDK提供的stop（）、destroy（）方法\n步骤\n1、设置标识符\n2、设置一个公开方法停止线程，转换标识符\n3、调用stop方法切换标识符，让线程停止\n线程休眠sleep\n1、sleep指定当前线程阻塞的毫秒数\n2、sleep存在异常interruptedException\n3、sleep时间达到后线程进入就绪状态\n4、sleep可以模拟网络延时、倒计时\n5、每一对象都有一把锁，sleep不会释放锁\n线程礼让yield\n1、礼让线程，让当前正在执行的线程暂停，但不阻塞\n2、将线程从运行状态变为就绪状态\n3、让cpu重新调度，礼让不一定成功，看CPU心情\n线程合并join\n1、join合并线程，待此线程执行完成后，在执行其他线程，其他线程阻塞\n2、可以想象成插队，执行完插队的内容，在执行主线程\n线程状态监测\nNEW 尚未启动线程\nRUNNABLE 在Java虚拟机执行的线程处于此状态\nBLOOKED 被阻塞\nWAITING  正在等待另一个线程执行特定的动作处于此状态\nTIMED WAITING 正在等待另一个执行动作达到指定等待时间的线程处于此状态\nTERMINATED\n已退出的线程\n线程优先级\n1、Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行\n2、线程的优先级用数字来表示，范围1到10\nThread.MIN_PRIORITY=1\nThread.MAX_PRIORITY=10\nThread.NORN_PRIORITY=5\n3、使用以下方式改变或获取优先级\ngetPority setPriority(int xxx)\n4、从数字高的先执行（但还是得看CPU调度）\n**优先级设定必须在\n守护（daemon）线程\n1、线程分为用户线程和守护线程\n2、虚拟机必须确保用户线程执行完毕 main\n3、虚拟机不用等待守护线程执行完毕   gc\n4、true为用户线程 false为守护线程\n如：后台记录操作日志，监控内存，垃圾回收\n4、线程同步机制\n==并发：同一个对象被多个线程同时操作==  例如：两个银行同时取钱\n现实生活中，遇到同一个戏院多个人想同时使用，比如食堂排队，每个人先吃饭，最简单的方式:排队\n处理多个线程问题，多个线程访问同一个对象时，并且某些线程还想修改这个对象，这时候我们就需要线程同步，线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程在使用\n形成条件：队列+==锁==\n由于同一进程的多个线程同时共享同一块存储空间，在带来方便的同时，也也带来访问冲突问题。为了保证数据在方法中被访问时的正确性，在访问时加入锁机制 ==synchronized== ，==当一个线程获得对象的锁。独占资源。其他线程笔其他对象必须等待，使用后释放锁即可，但存在以下问题：\n1、一个线程持有索会导致其他所有需要此锁的线程挂起\n2、在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延迟，引起性能问题\n3、如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题。比如：上大号和小号，性能低大号上厕所，小号性能高会等待的久\n同步synchronized\nsynchronized方法和synchronized块\n同步方法\npublic synchronized void method（int  args）{}\nsynchronized方法控制对象的访问，每个对象对应一把锁，每个==synchronized==**方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞。方法一旦调用，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程。**缺陷：==将一个大的方法声明为synchronized将会影响效率==\n同步块\nsynchronized（Obj）{}\n==Obj称为同步监视器，锁变化的量==\n**Obi可以是任何对象，**但是推荐使用共享资源作为同步监视器\n同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class【反射中讲解】\n同步监视器的执行过程：\n1、第一个线程访问，锁定同步监视器，执行其中代码\n2、第二个线程访问，发现同步监视器被锁定，无法访问\n3、第一个线程访问，解锁同步监视器\n4、第二个线程访问，发现同步监视器没有被锁定，然后锁定并访问\njuc安全集合\n==CopyOnWriteArrayList==所建立的对象是安全的\n5、死锁\n多个线程各自站有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，==某一个同步块同时拥有”两个以上对象的锁“时，就可能会发生”死锁“问题==\n例如：拿了这个锁，但还想要另一个所，但一个人只能有一个锁\n产生死锁的四个必要条件\n1、互斥条件：一个资源每次只能被一个进程使用\n2、请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放\n3、不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺、\n4、循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系\n==只要想办法破其中的任意一个或多个条件就可以避免死锁发生==\n6、Lock锁\n1、通过显示定义同步锁对象来实现同步，同步锁使用了Lock对象充当\n2、java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具，锁提供了对共享资源空间的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享对象之前先获的Lock对象\n3、ReentrantLock类实现Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的时ReentrantLock，可以显示加锁、释放锁\n12345678910111213class A&#123;   private final ReentrantLock lock&#x3D;new ReentratrLock();   public void m()&#123;   \t lock.lock();     try&#123;          &#125;     finally&#123;       lock.unlock();       &#x2F;&#x2F;如果同步代码块有异常，将unlock（）写入finally语句块     &#125;   &#125;&#125;\nSynchronized和Lock的对比\n==1、Lock是显示锁（手动开启和关闭锁），synchronized是隐式锁，出了作用域自动释放==\n2、Lock只有代码块锁，synchronized有代码块锁和方法锁\n3、使用Lock锁，JVM将花费较少的时间调度线程，性能更好，并且具有更好的拓展性\n优先使用顺序：Lock&gt;同步代码块（已经进入了方法体，分配了相应资源）&gt;同步方法(在方法体之外)\n7、线程通信\n分析：这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件\n1、对于生产者，没有生产产品之前，要通知消费者等待，而生产了产品之后，又需要马上通知消费者消费\n2、对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费\n==3、在生产者消费者问题中，仅有synchronized是不够的==\n​      ==synchronized可阻止并发更新同一个共享资源，实现了同步==\n​      ==synchronized不能用来实现不同线程之间的消息传递（通信）==\n方法\nwait（） 表示线程会一直等待，知道其他线程通知，与sleep不同，会释放锁\nwait（long times）指定等待的毫秒数\nnotify（）唤醒一个处于等待状态的线程\nnotifyAll（）唤醒同一个对象上所有调用wait（）方法的线程，优先级别高的线程优先调查\n均为Object类的方法，==都只能在同步方法或者同步代码块中使用==，否则会抛出异常IllegalMonitorStateException\n解决\n（1）并发协作模型”生产者/消费者模式“-&gt;管程法\n生产者：负责生产数据的模块（可能是方法，对象，线程，进程）\n消费者：负责处理数据的模块（可能是方法，对象，线程，进程）\n缓冲区：消费者不能直接使用生产者的数据，它们之间有个”缓冲区“\n==生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据==\n（2）并发协作模型”生产者/消费者模式“-&gt;信号灯法\n类似于”停止线程“\n注意\nsleep（） wait（）有try catch\n8、线程池\n背景：经常创建和销毁，使用量特别大，比如出现并发情况下的线程，对性能影响很大\n思路：提前创建好多个线程，放入线程池中，使用是直接获取，使用完放回池子中，可以避免频繁创建销毁、实现重复利用，类似交通工具\n好处：提高响应速度，降低资源耗损，便于线程管理\n方法：corePoolSize：核心池的大小\n​            maximumPoolSize：最大线程数\n​             keepAliveTime：线程没有任务时最多保持多长时间会终止\nExecutorService：真正线程池接口\n​                                 常见子类；void excute（Runnable command）——执\n​                                                    行命令，没有返回值\n​\t\t\t\t\t\t\t\t\t\t\t\t\tFuturesubmit(Callabletask)——\n​                                                    执行命令，有返回值\n​                                                    void  shutdown()——关闭连接池\nExecutors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池\n","plink":"http://example.com/2021/05/16/多线程/"},{"title":"Hello World","date":"2021-02-02T09:59:38.499Z","date_formatted":{"ll":"2021年2月2日","L":"2021/02/02","MM-DD":"02-02"},"updated":"2021-02-07T09:53:46.166Z","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n\nQuick Start\nCreate a new post\n1$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server\n1$ hexo server\nMore info: Server\nGenerate static files\n1$ hexo generate\nMore info: Generating\nDeploy to remote sites\n1$ hexo deploy\nMore info: Deployment\n","plink":"http://example.com/2021/02/02/hello-world/"}]