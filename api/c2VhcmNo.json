[{"title":"Typora常用快捷键","date":"2021-05-22T14:37:02.562Z","date_formatted":{"ll":"2021年5月22日","L":"2021/05/22","MM-DD":"05-22"},"updated":"2021-05-22T14:36:55.057Z","content":"Typora常用快捷键\n加粗：ctrl+B\n倾斜：ctrl+I\n下划线：ctrl+U\n标题：ctrl+H\n插入链接：ctrl+K\n创建表格：ctrl+T\n搜索：ctrl+F\n搜索并替换：ctrl+H\n返回Typora顶部：ctrl+Home\n返回Typora底部：ctrl+End\n插入代码：crtl+shift+C\n行内代码：ctrl+shift+K\n插入图片：ctrl+shift+I**\n无序列表：ctrl+shift+L\n选中某句话：ctrl+L\n选中某个单词：ctrl+D\n选中相同格式的文字：ctrl+E\n删除线：Alt+Shift+5\n引用：ctrl+shift+Q\n公共块：ctrl+shift+M\n撤销：ctrl+Z\n一级标题:ctrl+1(以\n","plink":"http://example.com/2021/05/22/Typora常用快捷键/"},{"title":"HTTP状态码","date":"2021-05-22T14:34:37.965Z","date_formatted":{"ll":"2021年5月22日","L":"2021/05/22","MM-DD":"05-22"},"updated":"2021-05-22T14:34:10.202Z","content":"HTTP状态码\n当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。\nHTTP状态码的英文为HTTP Status Code。\n常见的HTTP状态码\n200 - 请求成功\n301 - 资源（网页等）被永久转移到其它URL\n404 - 请求的资源（网页等）不存在\n500 - 内部服务器错误\nHTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：\nHTTP状态码分类\n分类\t分类描述\n1**\t信息，服务器收到请求，需要请求者继续执行操作\n2**\t成功，操作被成功接收并处理\n3**\t重定向，需要进一步的操作以完成请求\n4**\t客户端错误，请求包含语法错误或无法完成请求\n5**\t服务器错误，服务器在处理请求的过程中发生了错误\nHTTP状态码列表\n状态码\t状态码英文名称\t中文描述\n100\tContinue\t继续。客户端应继续其请求\n101\tSwitching Protocols\t切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议\n200\tOK\t请求成功。一般用于GET与POST请求\n201\tCreated\t已创建。成功请求并创建了新的资源\n202\tAccepted\t已接受。已经接受请求，但未处理完成\n203\tNon-Authoritative Information\t非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本\n204\tNo Content\t无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档\n205\tReset Content\t重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域\n206\tPartial Content\t部分内容。服务器成功处理了部分GET请求\n300\tMultiple Choices\t多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择\n301\tMoved Permanently\t永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替\n302\tFound\t临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI\n303\tSee Other\t查看其它地址。与301类似。使用GET和POST请求查看\n304\tNot Modified\t未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源\n305\tUse Proxy\t使用代理。所请求的资源必须通过代理访问\n306\tUnused\t已经被废弃的HTTP状态码\n307\tTemporary Redirect\t临时重定向。与302类似。使用GET请求重定向\n400\tBad Request\t客户端请求的语法错误，服务器无法理解\n401\tUnauthorized\t请求要求用户的身份认证\n402\tPayment Required\t保留，将来使用\n403\tForbidden\t服务器理解请求客户端的请求，但是拒绝执行此请求\n404\tNot Found\t服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置&quot;您所请求的资源无法找到&quot;的个性页面\n405\tMethod Not Allowed\t客户端请求中的方法被禁止\n406\tNot Acceptable\t服务器无法根据客户端请求的内容特性完成请求\n407\tProxy Authentication Required\t请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权\n408\tRequest Time-out\t服务器等待客户端发送的请求时间过长，超时\n409\tConflict\t服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突\n410\tGone\t客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置\n411\tLength Required\t服务器无法处理客户端发送的不带Content-Length的请求信息\n412\tPrecondition Failed\t客户端请求信息的先决条件错误\n413\tRequest Entity Too Large\t由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息\n414\tRequest-URI Too Large\t请求的URI过长（URI通常为网址），服务器无法处理\n415\tUnsupported Media Type\t服务器无法处理请求附带的媒体格式\n416\tRequested range not satisfiable\t客户端请求的范围无效\n417\tExpectation Failed\t服务器无法满足Expect的请求头信息\n500\tInternal Server Error\t服务器内部错误，无法完成请求\n501\tNot Implemented\t服务器不支持请求的功能，无法完成请求\n502\tBad Gateway\t作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应\n503\tService Unavailable\t由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中\n504\tGateway Time-out\t充当网关或代理的服务器，未及时从远端服务器获取请求\n505\tHTTP Version not supported\t服务器不支持请求的HTTP协议的版本，无法完成处理\n","plink":"http://example.com/2021/05/22/HTTP状态码/"},{"title":"窗口组件","date":"2021-05-22T14:31:29.274Z","date_formatted":{"ll":"2021年5月22日","L":"2021/05/22","MM-DD":"05-22"},"updated":"2021-05-22T14:31:23.518Z","content":"*Java Swing*  javax.swing.;  import java.awt.;\nGUI（Graphic User Interface）为程序提供图形界面，它最初的设计目的是构建一个通用的GUI,使其能在所有平台上运行。在Java1.0中基础类AWT（Abstract Windowing Toolkit）并没有达到这个要求，于是在Java2.0之后的版本出现了Swing，它是AWT组件的增强组件，但它并不能完全代替AWT组件，这两种组件需要同时出现在一个图形用户界面中。\nAWT(Abstract Windowing Toolkit)，中文译为抽象窗口工具包，是Java提供的用来建立和设置Java的图形用户界面的基本工具。AWT由Java中的java.awt包提供，里面包含了许多可用来建立与平台无关的图形用户界面(GUI)的类，这些类又被称为组件(components)。\nSwing是一个用于开发Java应用程序用户界面的开发工具包。它以抽象窗口工具包（AWT）为基础使跨平台应用程序可以使用任何可插拔的外观风格。Swing开发人员只用很少的代码就可以利用Swing丰富、灵活的功能和模块化组件来创建优雅的用户界面。\nAWT是重量级组件，操作系统不同表现不同。Swing组件不受影响，以J开头的组件都为swing组件\n窗口\n窗口是GUI编程的基础，**Java提供的JFrame类的实例是一个底层容器，**即通常所说的窗口。其他组件必须被添加到底层容器中，以便借助这个底层容器和操作系统进行信息交互。\nApplet窗口：Applet类管理这个窗口，当应用程序程序启动时，由系统创建和处理；\n框架窗口(JFrame)：这是通常意义上的窗口，它支持窗口周边的框架、标题栏，以及最小化、最大化和关闭按钮；也是container的间接子类，但需要一个窗口时，可使用JFrame或子类创建一个对象\n一种无边框窗口(JWindow)：没有标题栏，没有框架，只是一个空的矩形。\n\nFrame类的主要构造方法：\nJFrame()：创建无标题的窗口对象；\nJFrame(String s)：创建一个标题名是字符串s的窗口对象。\nJFrame类的其他常用方法：\n**setBounds(int x,int y,int width,int height)：**参数x,y指定窗口出现在\n屏幕的位置；参数width,height指定窗口的宽度和高度。单位是像素。\n**setSize(int width,int height)：**设置窗口的大小，参数width和height指定窗口的宽度和高度，单位是像素。\nsetLocation(int x,int y)：设置窗口位置，默认位置是（0，0）\nsetVisible(boolean b):设置窗口是否可见，窗口默认不可见，true 可见，false 不可见\nsetReaizable(boolean b):设置窗口是否可调整大小，窗口默认可调整dispose（）：撤销当前窗口，并释放当前窗口所需要的资源setExtendedState(int state)：设置窗口的拓展状态\nMAXIMIZED_HORIZ（水平方向最大化）\nMAXIMIZED_VERT（垂直方向最大化）\nMAXIMIZED_BOTH（水平、垂直方向最大化）\nsetDefaultCloseOperation(int operation)：该方法用来设置单击窗体右上角的关闭图标后，程序会做出怎么样的处理，其中参数取下列int型的static的常量，程序根据参数operation取值作出不同处理\nDO_NOTHING_ON_CLOSE（什么也不做）\nHIDE_ON_CLOSE（隐藏当前窗口）\nDISPOSE_ON_CLOSE（隐藏当前窗口，并释放窗体占有的其他资源）\nEXIT_ON_CLOSE（结束窗口所在的应用程序）\nsetBackground(Color c)：以参数 c设置窗口的背景颜色。\nsetForeground(Color c)：设置前景色为 c\nvid setTitle(String title)：设置窗口中的标题\n\n\n*字段摘要*\n*颜色*\n\n\n\n\nstatic Color black/BLACK\n黑色\n\n\nstatic Color blue/BLUE\n蓝色\n\n\nstatic Color cyan/CYAN\n青色\n\n\nstatic Color darkGray/DARK_GRAY\n深灰色\n\n\nstatic Color gray/GRAY\n灰色\n\n\nstatic Color green/GREEN\n绿色\n\n\nstatic Color lightGray/LIGHTGRAY\n浅灰色\n\n\nstatic Color magenta/MAGENTA\n洋红色\n\n\nstatic Color orange/ORANGE\n桔黄色\n\n\nstatic Color pink/PINK\n粉红色\n\n\nstatic Color red/RED\n红色\n\n\nstatic Color white/WHITE\n白色\n\n\nstatic Color yellow/YELLOW\n黄色\n\n\n*菜单条、菜单、菜单项*\n1、菜单条（JComponent类的子类JMenubar）\nFrame类中将菜单条放置到窗口中的方法：setMenuBar(MenuBar bar);该方法将菜单条添加到窗口的顶端。注意：只能向窗口添加一个菜单条。\n2、菜单（JComponent类的子类JMenu）\nMenu()：建立一个空标题的菜单。\nMenu(String s)：建立一个指定标题s的菜单。\npublic void add(MenuItem item)：向菜单添加菜单项item。\npublic void add(String s)：向菜单增加指定的选项。\npublic MenuItem getItem(int n)：得到指定索引处的菜单项。\npublic int getItemCount()：得到菜单选项数目。\npublic void insert(MenuItem item,int n)：在菜单的指定位置插入菜单选项。\npublic void insert(String s,int n)：在菜单指定位置插入菜单选项。\npublic void remove(int n)：删除菜单指定位置的菜单选项。\npublic void removeAll()：删除菜单的所有选项。\n3、菜单项（JComponent类的子类JMenuItem）\nMenuItem()：构造无标题菜单项。\nMenuItem(String s)：构造有标题菜单项。\npublic void setEnabled(boolean b)：设置当前菜单项是否可被\n选择。\npublic String getlabel()：得到菜单选项的名字。\npublic void addActionListener(ActionListener):向菜单项增加监视器，从菜单项接收行动事件（单击菜单项）。\n4、嵌入子菜单\nJMenu是JComponent类的子类，因此菜单本身也是一个菜单项，当把一个菜单看作菜单项添加到某个菜单中时，称这样的菜单为子菜单\n5、菜单上的图标\n为了使一个菜单上有一个图标，可以用图标类Icon声明一个图标，使用ImageIcon类创建一个图标\nIcon icon = new ImageIcon（“a.gif”);\n然后菜单项调用setIcon（Icon icon）方法将图标设置为icon\nmenu1.addSeparator();  //分割线\n*添加图片要添加文件夹 再用文件夹的地址*\n123456789101112131415161718192021222324252627282930313233343536373839package demo2;import java.awt.FlowLayout;import javax.swing.ButtonGroup;import javax.swing.JCheckBox;import javax.swing.JComboBox;import javax.swing.JFrame;import javax.swing.JRadioButton;public class Text1 extends JFrame&#123;\tJComboBox comboBox;    JRadioButton radioButton1,radioButton2;    ButtonGroup group;    JCheckBox checkBox1,checkBox2;    Text1()&#123;        setLayout(new FlowLayout());        checkBox1&#x3D;new JCheckBox(&quot;音乐天地&quot;);        checkBox2&#x3D;new JCheckBox(&quot;美术天地&quot;);        radioButton1&#x3D;new JRadioButton(&quot;男&quot;);        radioButton2&#x3D;new JRadioButton(&quot;女&quot;);        group&#x3D;new ButtonGroup();        group.add(radioButton1);        group.add(radioButton2);        comboBox&#x3D;new JComboBox();        comboBox.addItem(&quot;软件&quot;);        comboBox.addItem(&quot;计算机&quot;);        add(comboBox);        add(radioButton1);        add(radioButton2);        add(checkBox1);        add(checkBox2);                        setVisible(true);           &#x2F;&#x2F;DI.EXIT_ON_CLOSE        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);        setBounds(100,100,400,200);    &#125;    public static void main(String[] args) &#123;        Text1 text3&#x3D;new Text1();    &#125;&#125;\n*常用组件*\n常用组件都是JComponent的子类\nJTextField:文本框：允许用户输入单行文本\nJTextArea:文本区：允许用户输入多行文本\nJButton：按钮：单击 按钮\nJLabel：标签：为用户提供提示信息\nJCheckBox：复选框：为用户提供多项选择，有选中与未选中两种状态\nJRadioButton：单选按钮：为用户提供单项选择\nJComboBox：下拉列表：单项选择\nJPasswordField：密码框，默认显字符是*，可通过setEchoChar\n(char c)重新设置显字符\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package demo4;import javax.swing.*;import javax.swing.event.ChangeEvent;import javax.swing.event.ChangeListener;import java.awt.*;public class Main &#123;    public static void main(String[] args) &#123;        JFrame jf &#x3D; new JFrame(&quot;测试窗口&quot;);        jf.setSize(300, 300);        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);        jf.setLocationRelativeTo(null);        &#x2F;&#x2F; 创建选项卡面板        final JTabbedPane tabbedPane &#x3D; new JTabbedPane();        &#x2F;&#x2F; 创建第 1 个选项卡（选项卡只包含 标题）        tabbedPane.addTab(&quot;Tab01&quot;, createTextPanel(&quot;TAB 01&quot;));        &#x2F;&#x2F; 创建第 2 个选项卡（选项卡包含 标题 和 图标）        tabbedPane.addTab(&quot;Tab02&quot;, new ImageIcon(&quot;bb.jpg&quot;), createTextPanel(&quot;TAB 02&quot;));        &#x2F;&#x2F; 创建第 3 个选项卡（选项卡包含 标题、图标 和 tip提示）        tabbedPane.addTab(&quot;Tab03&quot;, new ImageIcon(&quot;bb.jpg&quot;), createTextPanel(&quot;TAB 03&quot;), &quot;This is a tab.&quot;);        &#x2F;&#x2F; 添加选项卡选中状态改变的监听器        tabbedPane.addChangeListener(new ChangeListener() &#123;            @Override            public void stateChanged(ChangeEvent e) &#123;                System.out.println(&quot;当前选中的选项卡: &quot; + tabbedPane.getSelectedIndex());            &#125;        &#125;);        &#x2F;&#x2F; 设置默认选中的选项卡        tabbedPane.setSelectedIndex(1);        jf.setContentPane(tabbedPane);        jf.setVisible(true);    &#125;    &#x2F;**     * 创建一个面板，面板中心显示一个标签，用于表示某个选项卡需要显示的内容     *&#x2F;    private static JComponent createTextPanel(String text) &#123;        &#x2F;&#x2F; 创建面板, 使用一个 1 行 1 列的网格布局（为了让标签的宽高自动撑满面板）        JPanel panel &#x3D; new JPanel(new GridLayout(1, 1));        &#x2F;&#x2F; 创建标签        JLabel label &#x3D; new JLabel(text);        label.setFont(new Font(null, Font.PLAIN, 50));        label.setHorizontalAlignment(SwingConstants.CENTER);        &#x2F;&#x2F; 添加标签到面板        panel.add(label);        return panel;    &#125;&#125;\n*常用容器*\nJcomponent是Container的子类，其创建的组件也是容器，容器经常用来添加组件，Jframe是底层容器，本届提到的容器被习惯的称作中间容器，中间容器必须添加到底层容器才能发挥作用\n1、JPanel面板：默认是FlowLayout布局，可以向面板中添加组件，再把面板添加到其他容器中\n2、JScrollPane：滚动窗格，可以将文本区放在滚动窗格中\nJScrollPane jScrollPane=new JScrollPane(new TextArea())\n3、JSplitPane：拆分窗格，可分为左右或上下两部分,有两个构造方法：\nJSplitPane(int a,Component b,Component c)\n//参数a决定时水平还是垂直：HORIZONTAL_SPLIT，VERTICAL_SPLIT\n如  JSplitPane jSplitPane=new JSplitPane(JSplitPane.VERTICAL_SPLIT,new JButton(),new JButton())\nJSplitPane(int a,boolean d,Component b,Component c)\n//参数d是决定拆分线移动时，组件是否连续变化，true是连续\n4、JLayeredPane：分层窗格\nadd（Jcomponent com，int layer）;添加组件com，并指定com所在的层\nsetLayer(Component c，int layer)可以设置组件c所在的层\ngetLayer(Component c)可以获取组件c所在的层数\n*常用布局*\n1、FlowLayout布局（流式布局） 左到右 上到下\n（一）创建布局对象 FlowLayout flow = new FlowLayout（），其对\n象调用相应的方法可以重新设置布局的对齐方式\n（二）容器con使用布局对象 con.setLayout（flow）\n（三）Con可以使用Container类提供的add方法将组建顺序的添加到容器中\n12345678910111213141516171819202122232425262728293031323334package demo3;import java.awt.FlowLayout;import javax.swing.JButton;import javax.swing.JFrame; public class FlowLayoutExample extends JFrame&#123;  JButton btn1&#x3D;new JButton(&quot;one&quot;); &#x2F;&#x2F;Button为按钮案件  JButton btn2&#x3D;new JButton(&quot;two&quot;);  JButton btn3&#x3D;new JButton(&quot;three&quot;);  JButton btn4&#x3D;new JButton(&quot;four&quot;);  JButton btn5&#x3D;new JButton(&quot;five&quot;);  FlowLayoutExample()&#123;    init();    this.setTitle(&quot;流式布局&quot;);    this.setResizable(true);    this.setSize(500, 200);    this.setLocationRelativeTo(null);    this.setDefaultCloseOperation(EXIT_ON_CLOSE);    this.setVisible(true);  &#125;  void init()&#123;    this.setLayout(new FlowLayout(FlowLayout.CENTER,10,5)); &#x2F;&#x2F;默认为居中;水平间距10，垂直间距5    this.add(btn1);    this.add(btn2);    this.add(btn3);    this.add(btn4);    this.add(btn5);  &#125;  public static void main(String args[])&#123;    new FlowLayoutExample();  &#125;&#125;\n2.BorderLayout布局（边界布局） 东南西北中\n（一）其布局是window型容器的默认布局\n（二）使用BorderLayout布局的容器con，可以使用add方法将一个组件b添加到中心区域\nCon.add（b，BorderLayout.CENTER）或\nCon.add（BorderLayout.CENTER，b）\n1234567891011121314151617181920212223242526272829303132333435package demo3;import java.awt.BorderLayout;import javax.swing.JButton;import javax.swing.JFrame; public class BorderLayoutExample extends JFrame&#123;  JButton btn1&#x3D;new JButton(&quot;东&quot;);  JButton btn2&#x3D;new JButton(&quot;南&quot;);  JButton btn3&#x3D;new JButton(&quot;西&quot;);  JButton btn4&#x3D;new JButton(&quot;北&quot;);  JButton btn5&#x3D;new JButton(&quot;中&quot;);  BorderLayoutExample()&#123;    init();    this.setTitle(&quot;边界布局&quot;);    this.setResizable(true);    this.setSize(200, 200);    this.setLocationRelativeTo(null);    this.setDefaultCloseOperation(EXIT_ON_CLOSE);    this.setVisible(true);  &#125;  void init()&#123;    this.setLayout(new BorderLayout(10,5)); &#x2F;&#x2F;默认为0，0；水平间距10，垂直间距5    this.add(btn1,BorderLayout.EAST);    this.add(btn2,BorderLayout.SOUTH);    this.add(btn3,BorderLayout.WEST);    this.add(btn4,BorderLayout.NORTH);    this.add(btn5,BorderLayout.CENTER);  &#125;  public static void main(String args[])&#123;    new BorderLayoutExample(); &#125;&#125;\n3、CardLayout布局（卡片布局）\n（一）创建布局对象\n（二）容器con使用布局对象\n（三）容器调用add（String s ，Component b）将组件b添加到容器，并给出了现实该组件代号s\n（三）布局对象card用CradLayout类提供的show（）方法，显示容器con中组件代号为s的组件 card.show（con，s）；\n4.GridLayout布局（网格布局）\n（一）创建布局对象，行m列n  GridLayout gird = new GridLayout（10，8）\n（二）容器调用add（Component c）将组件c加入容器中\n5.null布局（空布局）\n可以准确定位组件在容器的位置和大小，组件调用setBounds（int a，int b，int width，int height）方法可以设置本身的大小和在容器中的位置\n12345678910111213141516171819202122232425262728293031323334package demo3;import java.awt.GridLayout;import javax.swing.JButton;import javax.swing.JFrame; public class GridLayoutExample extends JFrame&#123;    JButton btn1&#x3D;new JButton(&quot;one&quot;);    JButton btn2&#x3D;new JButton(&quot;two&quot;);    JButton btn3&#x3D;new JButton(&quot;three&quot;);    JButton btn4&#x3D;new JButton(&quot;four&quot;);    JButton btn5&#x3D;new JButton(&quot;five&quot;);    GridLayoutExample()&#123;        init();        this.setTitle(&quot;表格布局&quot;);        this.setResizable(true);        this.setSize(300, 200);        this.setLocationRelativeTo(null);        this.setDefaultCloseOperation(EXIT_ON_CLOSE);        this.setVisible(true);    &#125;    void init()&#123;        this.setLayout(new GridLayout(2,3)); &#x2F;&#x2F;默认为1行，n列；2行3列，水平间距10，垂直间距5        this.add(btn1);        this.add(btn2);        this.add(btn3);        this.add(btn4);        this.add(btn5);    &#125;    public static void main(String args[])&#123;        new GridLayoutExample();    &#125;&#125;\nJTabbedPane（选项卡面板）\n常用构造方法:\ntabPlacement: 选项卡标题的位置, 值为 JTabbedPane.TOP、JTabbedPane.BOTTOM、 JTabbedPane.LEFT 或 JTabbedPane.RIGHT, 默认为 TOP\ntabLayoutPolicy: 选项卡位置不能放入所有的选项卡时，放置选项卡的策略，值为 JTabbedPane.WRAP_TAB_LAYOUT 或 JTabbedPane.SCROLL_TAB_LAYOUT\nJTabbedPane()\nJTabbedPane(int tabPlacement)\nJTabbedPane(int tabPlacement, int tabLayoutPolicy)\n创建选项卡:\ntitle: 选项卡的标题\nicon: 选项卡的图标\ntip: 当鼠标移到该选项卡时，悬浮提示的文本\ncomponent: 选中该选项卡时显示的内容组件\nvoid addTab(String title, Component component)\nvoid addTab(String title, Icon icon, Component component)\nvoid addTab(String title, Icon icon, Component component, String tip)\n在指定索引位置插入一个选项卡\nvoid insertTab(String title, Icon icon, Component component, String tip, int index\n移除选项卡:\n移除指定位置的选项（下面两个方法完全一致）\nvoid removeTabAt(int index)\nvoid remove(int index)\n移除指定内容控件的选项卡\nvoid remove(Component component)\n移除所有选项卡\nvoid removeAll()\n选项卡相关操作:\n设置当前选中的选项卡\nvoid setSelectedIndex(int index)\n获取当前选中的选项卡索引\nint getSelectedIndex()\n获取当前选中的选项卡对应的内容组件\nComponent getSelectedComponent()\n设置 index 位置的选项卡的标题\nvoid setTitleAt(int index, String title)\n设置 index 位置的选项卡的图标\nvoid setIconAt(int index, Icon icon)\n设置 index 位置的选项卡是否可用\nvoid setEnabledAt(int index, boolean enabled)\n将 index 位置的内容组件设置为 component\nvoid setComponentAt(int index, Component component)\n获取选项卡的数量\nint getTabCount()\n自定义选项卡标题位置的组件, 这里的 titleComponent 将放到选项卡标题位置。\n应用场景: 例如, 在选项卡标题位置添加一个关闭按钮, 点击按钮移除选项卡。\nvoid setTabComponentAt(int index, Component titleComponent)\n状态监听器:\n添加选项卡选中状态改变的监听器\nvoid addChangeListener(ChangeListener l)\n","plink":"http://example.com/2021/05/22/窗口组件/"},{"title":"网络编程","date":"2021-05-22T14:13:36.000Z","date_formatted":{"ll":"2021年5月22日","L":"2021/05/22","MM-DD":"05-22"},"updated":"2021-05-22T14:20:06.643Z","content":"1、概述\n地球村：你在西安打电话，美国可以收到\n打电话：–连接–接了–通话  TCP\n发短信：–发了就完事--  UDP\n\n**计算机网络：将地理位置不同==的具有独立功能的==多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议==的管理和协调下，实现资源共享**和信息传递的计算机系统。\n**网络编程的目的：**传播交流信息、数据交换、通信\n想要达到效果需要什么：\n1、如何准确定义网络上的主机：主机号、端口号、定位计算机某个资源\n2、找到了主机，如何传输数据\n注意\njavaweb：网页编程 B/S\n网络编程：TCP/IP   C/S  客户端\n2、网络通信的要素\n人工智能：智能汽车——工厂、人少，不能上市（伦理）！\n实现网络通信：通信双方的地址–ip+端口号   Eg：192.268.16.124：5900\n规则：网络通信的协议   http、ftp、smtp、tcp、udp\nTCP/IP模型，传输层所学重点\n\n小结\n1、网络编程中主要的两个问题\n​      (1)如何准确定位网络上的一台或者多台主机\n​      (2)找到主机之后如何进行通信\n![img](file:///C:\\Users\\Administrator\\AppData\\Roaming\\Tencent\\Users\\1917429455\\QQ\\WinTemp\\RichOle\\C9VGX_[SD9Z%RBT{PGVB}00.png)\n2、网络编程的要素\n（1）ip和端口号\n（2）网络通信协议\n3、万物皆对象，有相关的类没有就创建\n3、IP\nip地址：InetAddress\n(1)唯一定位一台网络上计算机\n(2)127.0.0.1:本机上的ip\n(3)ip地址的分类：\n通过ip地址分配（ipv4/ipv6）\n–ipv4：127.0.0.1，由四个字节组成，0~255\n–ipv6： fe80::60e6:343f:6d9b:49f7%18，128位，8个无符号整数，abcd\n公网（互联网使用）-私网（局域网使用）\n1、192.168.xx.xxx  专门给组织内部使用\n2、ABCD类 地址（阿里笔试）\n域名的诞生—记忆ip的问题\n1234567891011121314151617181920212223242526272829303132import java.net.InetAddress;import java.net.UnknownHostException;public class TestInetAddress &#123;&#x2F;&#x2F;测试ip\tpublic static void main(String[] args) &#123;\t\ttry&#123;\t\t\t&#x2F;&#x2F;查询本机地址\t\t\tInetAddress inet1&#x3D;InetAddress.getByName(&quot;127.0.0.1&quot;);\t\t\tSystem.out.println(inet1);\t\t\tInetAddress inet2&#x3D;InetAddress.getByName(&quot;localhost&quot;);\t\t\tSystem.out.println(inet2);\t\t\tInetAddress inet3&#x3D;InetAddress.getLocalHost();\t\t\tSystem.out.println(inet3);\t\t\t\t\t\t&#x2F;&#x2F;查询网站ip地址\t\t\tInetAddress inet4&#x3D;InetAddress.getByName(&quot;www.baidu.com&quot;);\t\t\tSystem.out.println(inet4);\t\t\t\t\t\t&#x2F;&#x2F;常用方法\t\t\t&#x2F;&#x2F;System.out.println(inet4.getAddress());\t\t\tSystem.out.println(inet4.getCanonicalHostName());\t\t\tSystem.out.println(inet4.getHostAddress());\t\t\tSystem.out.println(inet4.getHostName());\t\t&#125;catch(UnknownHostException e)&#123;\t\t\te.printStackTrace();\t\t&#125;\t\t\t\t&#125;\t&#125;\n4、端口\n表示计算机上一个程序的进程\nEg：每栋楼是一个ip，每个居民端口\n（1)不同的进程有不同的端口号，用来区分软件，ip区分地址，可以有\n​       0~655354个软件\n(2)分为TCP和UDP，单个协议下面端口号不能冲突  Eg：tcp=80，udp=80\n​     是错的\n端口分类：（1）公有端口 0~1023\n​                    http80、 https 443 、ftp21 、telent23\n​\t\t\t\t\t相当于https://1/=heeps://1:443/\n​                   （2）程序注册端口 2014~49151   分配用户或程序\n​                       Tomcat8080、MySql3306、Oracle1521\n​                   （3）动态私有：49152~65535\n12341 netstat -ano #查看所有的端口2 netstat -ano|findstr &quot;5900&quot; #查看指定的端口号3 tasklisdt|findstr &quot;8787&quot; #查看指定端口的远程4 ctrl+shift+esc #打开任务管理器\n1234567891011import java.net.InetSocketAddress;public class TestInetStockAddress &#123;\tpublic static void main(String []args)&#123;\t\tInetSocketAddress a&#x3D;new InetSocketAddress(&quot;222&quot;,0000);\t\tSystem.out.println(a);\t\tSystem.out.println(a.getAddress());\t\tSystem.out.println(a.getPort());\t&#125;&#125;\n5、通信协议\n协议：约定，就好比上课约定好用普通话，进行交流\n网络通信协议：速率、传输码率、代码结构、传输控制\n大事化小：分层！\nTCP/IP协议-实际上位一组协议\n重要：（1）TCP：用户传输协议\n​            （2）UDP：用户数据报协议\n出名的协议：（1）TCP：用户传输协议\n​                       （2） IP：网络互连协议\nTCP、UDP对比\nTCP：打电话\n（1）连接、稳定\n（2）三次握手、四次挥手\n1234567891、最少需要三次，保证稳定链接A:你干嘛B：吃饭A：我也要2、最少需要四次，保证断开A：我要走了B：我真的要走吗?B：我真的真的真的要走吗？A：真的要走！\n（3）客户端、服务端\n（4）传输完成、释放连接、效率低\nUDP：发短信\n（1）不连接、不稳定\n（2）客户端、服务端：没有明确的界限\n（3）不管有没有准备好，都可以发送给你，类似于导弹\n6、TCP\n客户端：在web中是以request对象存在的,发送请求给服务器端处理.\n服务端 ：顾名思义是服务的,客户端发送的请求交给服务器端处理,是以response对象存在,服务器端处理完毕后反馈给客户端。\n一般我们访问网站,都是客户端(浏览器、app)发出请求,然后**对方服务器端(sina,sohu)响应,**结果就是返回了页面路径给我们,我们再根据路径看到了网页。\n1又叫主从式架构，简称C&#x2F;S结构，是一种网络架构，它把客户端 (Client) (通常是一个采用图形用户界面的程序)与服务器 (Server) 区分开来。每一个客户端软件的实例都可以向一个服务器或应用程序服务器发出请求。有很多不同类型的服务器，例如文件服务器、终端服务器和邮件服务器等。虽然它们的存在的目的不一样，但基本构架是一样的。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.InetAddress;import java.net.ServerSocket;import java.net.Socket;import java.net.UnknownHostException;\t&#x2F;&#x2F;服务器端public class TopClimtDemo01 &#123;\tpublic static void main(String[] args) &#123;\t\tServerSocket s&#x3D;null;\t\tSocket a&#x3D;null;\t\tInputStream is&#x3D;null;\t\tByteArrayOutputStream baos&#x3D;null;\t\ttry&#123;\t\t\t&#x2F;&#x2F;有一个服务器地址\t\t    s&#x3D;new ServerSocket(7888);&#x2F;&#x2F;创建绑定到指定端口的服务器套接字。\t\t\t&#x2F;&#x2F;等待客户端连接侦听与此套接字建立的连接并接受它。 该方法将阻塞，直到建立连接为止。\t\t\ta&#x3D;s.accept();            &#x2F;*创建一个新的Socket，如果有安全管理器，则使用s.getInetAddress（）            getHostAddress（）和s.getPort（）作为其参数来调用安全管理器的checkAccept方             法，以确保允许该操作，这可能会导致 SecurityException。*&#x2F;\t\t\t&#x2F;&#x2F;读取客户端信息\t\t    is&#x3D;a.getInputStream();\t\t\t&#x2F;&#x2F;管道流\t\t\tbaos&#x3D;new ByteArrayOutputStream();\t\t\tbyte[] b&#x3D;new byte[1024];\t\t\tint len;\t\t\twhile((len&#x3D;is.read(b))!&#x3D;-1)&#123;\t\t\t\tbaos.write(b,0,len);\t\t\t&#125;\t\t\tSystem.out.println(baos.toString());\t\t\t&#125;catch(IOException e)&#123;\t\t\t\te.printStackTrace();\t\t\t&#125;finally&#123;\t\t\t\tif(baos!&#x3D;null)&#123;\t\t\t\t  try &#123;\t\t\t\t\tbaos.close();\t\t\t\t  &#125; catch (IOException e) &#123;\t\t\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\tif(is!&#x3D;null)&#123;\t\t\t\ttry &#123;\t\t\t\t\tis.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\tif(s!&#x3D;null)&#123;\t\t\t\ttry &#123;\t\t\t\t\ts.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\tif(a!&#x3D;null)&#123;\t\t\t\ttry &#123;\t\t\t\t\ta.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t\t&#125;&#125;&#x2F;&#x2F;客户端public class TopServeDemo01 &#123;\tpublic static void main(String []args)&#123;\t\tSocket a&#x3D;null;\t\tOutputStream w&#x3D;null;\t\ttry&#123;\t\t\t&#x2F;&#x2F;知道服务器的地址\t\t\tInetAddress sIP&#x3D;InetAddress.getByName(&quot;127.0.0.1&quot;);\t\t\t&#x2F;&#x2F;知道端口号\t\t\tint port&#x3D;7888;\t\t\t&#x2F;&#x2F;创建一个socket的连接\t\t\ta&#x3D;new Socket(sIP,port);\t\t\t&#x2F;&#x2F;发送消息  IO流\t\t\tw&#x3D;a.getOutputStream();\t\t\tw.write(&quot;你好,欢迎来&quot;.getBytes());\t\t&#125;\t\tcatch(Exception e)&#123;\t\t\te.printStackTrace();\t\t&#125;finally&#123;\t\t\t&#x2F;&#x2F;关闭资源\t\t\tif(w!&#x3D;null)&#123;\t\t\ttry &#123;\t\t\t\tw.close();\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\t&#125;\t\t\tif(a!&#x3D;null)&#123;\t\t\ttry &#123;\t\t\t\ta.close();\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t&#x2F;&#x2F; TODO Auto-generated catch block\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n7、文件上传\n把文件变成流 读出来\nlocalhost、127.0.0.1 和 本机IP之间的区别：\n1、localhost等于127.0.0.1，不过localhost是域名，127.0.0.1是IP地址。\n2、localhost和127.0.0，不需要联网，都是本机访问。\n3、本机IP需要联网，本机IP是本机或外部访问， 本机 IP 就是本机对外放开访问的IP地址，这个网址就是与物理网卡绑定的IP地址。\n8、Tomacat\n服务器：自定义S\n​               Tomcat服务器S\n客户端：自定义c\n​                浏览器B\n9、UDP\n发短信：不用连接，需要知道对方地址\nDatagramPacket   数据发送包相当于信件   DatagramSocket 接受包\n1234567891011121314151617181920212223242526272829303132333435363738394041package Demo03;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.SocketException;&#x2F;&#x2F;接收端public class UDPClimeDemo03 &#123;\tpublic static void main(String []args) throws IOException&#123;\t\t&#x2F;&#x2F;开放端口\t\tDatagramSocket so&#x3D;new DatagramSocket(2022);\t\tbyte []buffer&#x3D;new byte[1024];\t\tDatagramPacket pocket&#x3D;new DatagramPacket(buffer,0,buffer.length);\t\tso.receive(pocket);\t\tSystem.out.println(pocket.getAddress().getHostAddress());\t\tSystem.out.println(new String(pocket.getData(),0,pocket.getLength()));\t\t&#x2F;&#x2F;关闭连接\t\tso.close();\t&#125;&#125;public class UdpServeDemo03 &#123;&#x2F;&#x2F;发送端\tpublic static void main(String[] args) throws Exception &#123;\t\t&#x2F;&#x2F;1、建立一个Socket\t\tDatagramSocket socket&#x3D;new DatagramSocket();\t\t&#x2F;&#x2F;2、建个包\t\tString m&#x3D;&quot;你好啊,服务器&quot;;\t\tInetAddress localhost&#x3D;InetAddress.getByName(&quot;localhost&quot;);\t\tint port&#x3D;2022;\t\t&#x2F;&#x2F;数据、数据的长度起始要发送给谁\t\tDatagramPacket pocket&#x3D;new DatagramPacket(m.getBytes(),0,m.getBytes().length,localhost,port);\t\t&#x2F;&#x2F;3、发送包\t\tsocket.send(pocket);\t\t&#x2F;&#x2F;4、关闭流\t\tsocket.close();\t&#125;&#125;\n123456789101112131415161718package Demo06;import java.net.MalformedURLException;import java.net.URL;public class Url &#123;\tpublic static void main(String[] args) throws MalformedURLException &#123;\t\tURL url&#x3D;new URL(&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;hellowworld&#x2F;indextsjsajads&quot;);\t\tSystem.out.println(url.getFile());\t\tSystem.out.println(url.getHost());\t\tSystem.out.println(url.getPath());\t\tSystem.out.println(url.getQuery());\t\tSystem.out.println(url.getProtocol());\t&#125;&#125;\n","plink":"http://example.com/2021/05/22/网络编程/"},{"title":"多线程","date":"2021-05-22T13:29:16.000Z","date_formatted":{"ll":"2021年5月22日","L":"2021/05/22","MM-DD":"05-22"},"updated":"2021-05-22T14:24:51.332Z","content":"1、概念\n多任务\n边吃饭边看手机，看起来是多个任务，但在同一时间里只做了一件事情\n多线程\n原来只有一条车道，慢慢因为车多了，道路堵塞，效率降低，因此开辟了一条道路\n普通方法和多线程\n\n进程(process)和线程(Thread)关系\n**一个进程可以有多个线程，**如视频中同时听到声音，看到图片，看弹幕等。一个进程至少有一个线程，线程是CPU调度和执行的单位\n很多多线程是模拟出来的，真正的多线程是多个CPU，即多核，如服务器\n程序：是指令和数据的有序集合，其本身没有，任何运行的含义，是一个静态的概念\n进程：是执行程序的一次执行过程，是一个动态的概念，是系统资源分配的单位\n核心\n1、线程是独立的执行路径\n2、在程序运行时，后台会有多个路径，如主线程和gc线程（即垃圾回收进程）\n3、main（）称之为主线程，为系统的入口，用于执行整个程序\n4、在一个进程中，如果开辟了多个线程，线程的运行由调度器安排，调度器与操作系统相关，先后顺序是不能人为的干预的\n5、对同一份资源操作时，会存在资源抢夺问题，需要加入并发控制\n6、线程会带来额外的开销，如Cpu调度时间，并发控制开销\n7、每个线程在自己的工作内存交互，内存控制不当会造成数据不一致\n2、线程的创建\nThread class    继承Thread类（重点）-------API\nRunnable 实现Runnable接口（重点）\nCallable  实现Callable接口（了解）\nThread class\n**继承Thread类，重写run方法，创建对象，调用start（）**方法启动\nstart（）使得交替执行，没有先后顺序\nRunnable\n一个类继承该接口，重写run方法，创建该类的对象，将Thread实例化并赋给它，再用start\nThread方法\n1public static Thread currentThread()\n返回对当前正在执行的线程对象的引用。\n12public static void sleep(long millis)                  throws InterruptedException\n使当前正在执行的线程以指定的毫秒数暂停(暂时停止执行)，具体取决于系统定时器和调度程序的精度和准确性。 线程不会丢失任何显示器的所有权。\n小结\nThread：1、子类继承Thread类具备多线程能力\n​                 2、启动线程：子类对象.start()\n​                 3、不建议：避免OOP单继承局限性\nRunnable：1、实现Runnable具有多线程能力\n​                     2、启动线程：传入目标对象+Thread对象.start()\n​                     3、推荐：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用\n实现Callable接口（了解）\n1、实现Callable接口，需要返回值类型\n2、重写call方法，需要抛出异常\n3、创建目标对象\n4、创建执行服务  ExecutorService ser=Executors.newFixedThreadPool(线程个数);\n5、提交执行：Futureresult1=ser.submit(线程名称)\n6、获取结果：boolean r=result1.get()\n7、关闭服务：ser.shutdownNow();\n\nCallable好处\n1、可以定义为返回值\n2、可以抛出异常\n静态代理（进程的实现原理）\n你：真实角色\n婚庆公司：代理你，帮你处理结婚的事情\n结婚：实现结婚的接口\n总结\n真实对象和代理对象都要实现同一个接口，代理对象要先代理真实角色\n好处\n代理对象可以实现很多真实对象做不了的事情\n真实对象专注做自己的事情\nLamda表达式-\n定义：\n任何接口，如果只包含唯一一个抽象方法，那么他就是一个函数式接口\n12345public interface Runable&#123;     public abstract void run（）；&#125;\n对于函数式接口，我们可以通过lamda表达式来创建该接口的对象\n最普通 静态内部类 局部内部类  匿名内部类  拉姆达类\n好处\n避免匿名内部类定义过多\n其实质属于函数式编程的概念\n对象=()-&gt;{…}\n带有参数\n1、直接代入\n2、参数类型删去\n3、删去括号\n4、删去花括号**，但只能是一条语句**（以上可以一起执行)\n5、有多个参数类型。去掉参数，用逗号隔开且用括号括起来\n3、线程状态\n\n1000毫秒=1秒\n停止线程\n1、推荐线程自己停止下来\n2、建议使用一个标志位进行终止变量，当flag=false，则终止线程运行\n3、不推荐使用JDK提供的stop()、destroy()方法\n步骤\n1、设置标识符\n2、设置一个公开方法停止线程，转换标识符\n3、调用stop方法切换标识符，让线程停止\n1234567891011121314151617181920212223242526272829package stop;public class One implements Runnable&#123;\tprivate boolean flag&#x3D;false;\tpublic void run()&#123;\t    int i&#x3D;0;\t\twhile(flag)&#123;\t\t\tSystem.out.println(&quot;run&quot;+i);\t\t&#125;\t&#125;\t&#x2F;&#x2F;设置一个方法让线程停止\tpublic void stop()&#123;\t\tthis.flag&#x3D;true;\t&#125;\tpublic static void main(String[]args)&#123;\t\tOne o&#x3D;new One();\t\tnew Thread(o).start();\t\tfor(int i&#x3D;0;i&lt;2000;i++)&#123;\t\t\tSystem.out.println(&quot;mmm&quot;+i);\t\t\tif(i&#x3D;&#x3D;1000)&#123;\t\t\t&#x2F;&#x2F;调用stop方法切换标志位，让线程停止\t\t\t\to.stop();\t\t\t\tSystem.out.println(&quot;线程停止了&quot;);\t\t\t&#125;\t\t&#125;\t&#125;\t&#125;\n线程休眠sleep\n1、sleep指定当前线程阻塞的毫秒数\n2、sleep存在异常interruptedException\n3、sleep时间达到后线程进入就绪状态\n4、sleep可以模拟网络延时、倒计时\n5、每一对象都有一把锁，sleep不会释放锁\n12345678910111213141516171819202122232425package baobie;public class 线程睡眠 &#123;\tpublic static void main(String[]args)&#123;\t\ttry&#123;\t\t\ttime();\t\t&#125;\t\tcatch(InterruptedException e)&#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;\tpublic static void time() throws InterruptedException&#123;\t\tint rum&#x3D;10;\t\twhile(true)&#123;\t\t\tThread.sleep(1000);\t\t\tSystem.out.println(rum--);\t\t\tif(rum&lt;&#x3D;0)&#123;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n线程礼让yield\n1、礼让线程，让当前正在执行的线程暂停，但不阻塞\n2、将线程从运行状态变为就绪状态\n3、让cpu重新调度，礼让不一定成功，看CPU心情\n123456789101112131415161718package baobie;public class 线程yield &#123;\tpublic static void main(String[] args) &#123;\t\tmyYield t&#x3D;new myYield();\t\tnew Thread(t,&quot;小明&quot;).start();\t\tnew Thread(t,&quot;小黑&quot;).start();\t&#125;&#125;class myYield implements Runnable&#123;\t\tpublic void run()&#123;\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;开始执行&quot;);\t\t\tThread.yield();\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;停止执行&quot;);\t&#125;\t&#125;\n线程合并join\n1、join合并线程，待此线程执行完成后，在执行其他线程，其他线程阻塞\n2、可以想象成插队，执行完插队的内容，在执行主线程\n123456789101112131415161718192021222324package baobie;public class 线程join &#123;\tpublic static void main(String[] args) throws InterruptedException &#123;\t\tjoins a&#x3D;new joins();\t\tThread b&#x3D;new Thread(a);\t\tb.start();\t\t\t\tfor(int j&#x3D;0;j&lt;400;j++)&#123;\t\t\tif(j&#x3D;&#x3D;100)&#123;\t\t\t   b.join();\t\t\t&#125;\t\t\tSystem.out.println(&quot;main&quot;+j);\t\t&#125;\t&#125;&#125;class joins implements Runnable&#123;\tpublic void run()&#123;\t\tfor(int i&#x3D;0;i&lt;1000;i++)&#123;\t\t   System.out.println(&quot;线程VIP来了&quot;+i);\t\t&#125;\t&#125;\n线程状态监测\nNEW 尚未启动线程\nRUNNABLE 在Java虚拟机执行的线程处于此状态\nBLOOKED 被阻塞\nWAITING  正在等待另一个线程执行特定的动作处于此状态\nTIMED WAITING 正在等待另一个执行动作达到指定等待时间的线程处于此状态\nTERMINATED\n已退出的线程\n线程优先级\n1、Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行\n2、线程的优先级用数字来表示，范围1到10\nThread.MIN_PRIORITY=1\nThread.MAX_PRIORITY=10\nThread.NORN_PRIORITY=5\n3、使用以下方式改变或获取优先级\ngetPority setPriority(int xxx)\n4、从数字高的先执行（但还是得看CPU调度）\n1234567891011121314151617181920212223242526272829303132333435363738package baobie;public class 线程优先级 &#123;\tpublic static void main(String[] args)&#123;\t\tSystem.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+Thread.currentThread().getPriority());\t\t&#x2F;&#x2F;main方法默认为5\t\tmyPriority n&#x3D;new myPriority();\t\tThread t1&#x3D;new Thread(n);\t\tThread t2&#x3D;new Thread(n);\t\tThread t3&#x3D;new Thread(n);\t\tThread t4&#x3D;new Thread(n);\t\tThread t5&#x3D;new Thread(n);\t\tThread t6&#x3D;new Thread(n);\t\t\t\tt1.start();&#x2F;&#x2F;默认\t\t\t\tt2.setPriority(1); \t\tt2.start();\t\t\t\tt3.setPriority(4);\t\tt3.start();\t\t\t\tt4.setPriority(9);\t\tt4.start();\t\tt5.setPriority(-1);\t\tt5.start();\t&#x2F;&#x2F;\tt6.setPriority(11);\t&#x2F;&#x2F;\tt6.start();\t&#125;&#125;class myPriority implements Runnable&#123;\tpublic void run()&#123;\t\tSystem.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+Thread.currentThread().getPriority());\t&#125;&#125;\n守护(daemon)线程\n1、线程分为用户线程和守护线程\n2、虚拟机必须确保用户线程执行完毕 main\n3、虚拟机不用等待守护线程执行完毕   gc\n4、true为用户线程 false为守护线程\n如：后台记录操作日志，监控内存，垃圾回收\n12345678910111213141516171819202122232425262728293031323334package baobie;public class 守护线程 &#123;\tpublic static void main(String[] args)&#123;\t\tGod g&#x3D;new God();\t\tuser u&#x3D;new user();\t\t\t\tThread t&#x3D;new Thread(g);\t\tt.setDaemon(true);&#x2F;&#x2F;true为守护线程\t\tt.start();&#x2F;&#x2F;守护线程启动\t\t&#x2F;&#x2F;new Thread(u).start();&#x2F;&#x2F;用户线程\t\tThread k&#x3D;new Thread(u);\t\tk.setDaemon(false);&#x2F;&#x2F;默认为false 则是用户线程 正常的线程都是用户线程\t\tk.start();&#x2F;&#x2F;用户线程启动\t&#125; &#125;\t&#x2F;&#x2F;守护线程\tclass God implements Runnable&#123;\t\tpublic void run()&#123;\t\t\twhile(true)&#123;\t\t\t\tSystem.out.println(&quot;上帝保佑你&quot;);\t\t\t&#125;\t\t&#125;\t&#125;\t&#x2F;&#x2F;用户线程\tclass user implements Runnable&#123;\t\tpublic void run()&#123;\t\t\tfor(int i&#x3D;0;i&lt;20;i++)&#123;\t\t\t\tSystem.out.println(&quot;好人一生平安&quot;+i);&#x2F;&#x2F;用户线程必须执行完毕\t\t\t&#125;\t\tSystem.out.println(&quot;Good byb&quot;);\t\t&#125;\t&#125;\n4、线程同步机制\n并发：同一个对象被多个线程同时操作  例如：两个银行同时取钱\n现实生活中，遇到同一个戏院多个人想同时使用，比如食堂排队，每个人先吃饭，最简单的方式:排队\n处理多个线程问题，多个线程访问同一个对象时，并且某些线程还想修改这个对象，这时候我们就需要线程同步，线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程在使用\n形成条件：队列+锁\n由于同一进程的多个线程同时共享同一块存储空间，在带来方便的同时，也也带来访问冲突问题。为了保证数据在方法中被访问时的正确性，在访问时加入锁机制 synchronized ，当一个线程获得对象的锁。独占资源。其他线程笔其他对象必须等待，使用后释放锁即可，但存在以下问题：\n1、一个线程持有索会导致其他所有需要此锁的线程挂起\n2、在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延迟，引起性能问题\n3、如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题。比如：上大号和小号，性能低大号上厕所，小号性能高会等待的久\n同步synchronized\nsynchronized方法和synchronized块\n同步方法\npublic synchronized void method(int  args){ }\nsynchronized方法控制对象的访问，每个对象对应一把锁，每个**synchronized****方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞。方法一旦调用，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程。**缺陷：将一个大的方法声明为synchronized将会影响效率\n同步块\nsynchronized（Obj）{}\n==Obj称为同步监视器，锁变化的量==\n**Obi可以是任何对象，**但是推荐使用共享资源作为同步监视器\n同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class【反射中讲解】\n同步监视器的执行过程：\n1、第一个线程访问，锁定同步监视器，执行其中代码\n2、第二个线程访问，发现同步监视器被锁定，无法访问\n3、第一个线程访问，解锁同步监视器\n4、第二个线程访问，发现同步监视器没有被锁定，然后锁定并访问\njuc安全集合\nCopyOnWriteArrayList所建立的对象是安全的\n5、死锁\n多个线程各自站有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，某一个同步块同时拥有”两个以上对象的锁“时，就可能会发生”死锁“问题\n例如：拿了这个锁，但还想要另一个所，但一个人只能有一个锁\n产生死锁的四个必要条件\n1、互斥条件：一个资源每次只能被一个进程使用\n2、请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放\n3、不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺、\n4、循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系\n只要想办法破其中的任意一个或多个条件就可以避免死锁发生\n6、Lock锁\n1、通过显示定义同步锁对象来实现同步，同步锁使用了Lock对象充当\n2、java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具，锁提供了对共享资源空间的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享对象之前先获的Lock对象\n3、ReentrantLock类实现Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的时ReentrantLock，可以显示加锁、释放锁\n12345678910111213class A&#123;   private final ReentrantLock lock&#x3D;new ReentratrLock();   public void m()&#123;   \t lock.lock();     try&#123;          &#125;     finally&#123;       lock.unlock();       &#x2F;&#x2F;如果同步代码块有异常，将unlock（）写入finally语句块     &#125;   &#125;&#125;\nSynchronized和Lock的对比\n1、Lock是显示锁(手动开启和关闭锁)，synchronized是隐式锁，出了作用域自动释放\n2、Lock只有代码块锁，synchronized有代码块锁和方法锁\n3、使用Lock锁，JVM将花费较少的时间调度线程，性能更好，并且具有更好的拓展性\n优先使用顺序：Lock&gt;同步代码块（已经进入了方法体，分配了相应资源）&gt;同步方法(在方法体之外)\n7、线程通信\n分析：这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件\n1、对于生产者，没有生产产品之前，要通知消费者等待，而生产了产品之后，又需要马上通知消费者消费\n2、对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费\n3、在生产者消费者问题中，仅有synchronized是不够的\n​      synchronized可阻止并发更新同一个共享资源，实现了同步\n​      synchronized不能用来实现不同线程之间的消息传递(通信)\n方法\nwait() 表示线程会一直等待，知道其他线程通知，与sleep不同，会释放锁\nwait(long times)指定等待的毫秒数\nnotify() 唤醒一个处于等待状态的线程\nnotifyAll() 唤醒同一个对象上所有调用wait() 方法的线程，优先级别高的线程优先调查\n均为Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常IllegalMonitorStateException\n解决\n（1）并发协作模型”生产者/消费者模式“-&gt;管程法\n生产者：负责生产数据的模块(可能是方法，对象，线程，进程)\n消费者：负责处理数据的模块(可能是方法，对象，线程，进程)\n缓冲区：消费者不能直接使用生产者的数据，它们之间有个”缓冲区“\n生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据\n（2）并发协作模型”生产者/消费者模式“-&gt;信号灯法\n类似于”停止线程“\n注意\nsleep（） wait（）有try catch\n8、线程池\n背景：经常创建和销毁，使用量特别大，比如出现并发情况下的线程，对性能影响很大\n思路：提前创建好多个线程，放入线程池中，使用是直接获取，使用完放回池子中，可以避免频繁创建销毁、实现重复利用，类似交通工具\n好处：提高响应速度，降低资源耗损，便于线程管理\n方法：corePoolSize：核心池的大小\n​            maximumPoolSize：最大线程数\n​             keepAliveTime：线程没有任务时最多保持多长时间会终止\nExecutorService：真正线程池接口\n​                                 常见子类；void excute(Runnable command)——执\n​                                                    行命令，没有返回值\n​\t\t\t\t\t\t\t\t\t\t\t\t\tFuturesubmit(Callabletask)——\n​                                                    执行命令，有返回值\n​                                                    void  shutdown()——关闭连接池\nExecutors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池\n","plink":"http://example.com/2021/05/22/多线程/"},{"title":"Hello World","date":"2021-02-02T09:59:38.499Z","date_formatted":{"ll":"2021年2月2日","L":"2021/02/02","MM-DD":"02-02"},"updated":"2021-02-07T09:53:46.166Z","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n\nQuick Start\nCreate a new post\n1$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server\n1$ hexo server\nMore info: Server\nGenerate static files\n1$ hexo generate\nMore info: Generating\nDeploy to remote sites\n1$ hexo deploy\nMore info: Deployment\n","plink":"http://example.com/2021/02/02/hello-world/"}]