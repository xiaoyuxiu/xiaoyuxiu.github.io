[{"title":"窗口组件","date":"2021-05-22T07:56:57.071Z","date_formatted":{"ll":"2021年5月22日","L":"2021/05/22","MM-DD":"05-22"},"updated":"2021-05-16T08:35:16.395Z","content":"*Java Swing*  javax.swing.;  import java.awt.;\nGUI（Graphic User Interface）为程序提供图形界面，它最初的设计目的是构建一个通用的GUI,使其能在所有平台上运行。在Java1.0中基础类AWT（Abstract Windowing Toolkit）并没有达到这个要求，于是在Java2.0之后的版本出现了Swing，它是AWT组件的增强组件，但它并不能完全代替AWT组件，这两种组件需要同时出现在一个图形用户界面中。\nAWT(Abstract Windowing Toolkit)，中文译为抽象窗口工具包，是Java提供的用来建立和设置Java的图形用户界面的基本工具。AWT由Java中的java.awt包提供，里面包含了许多可用来建立与平台无关的图形用户界面(GUI)的类，这些类又被称为组件(components)。\nSwing是一个用于开发Java应用程序用户界面的开发工具包。它以抽象窗口工具包（AWT）为基础使跨平台应用程序可以使用任何可插拔的外观风格。Swing开发人员只用很少的代码就可以利用Swing丰富、灵活的功能和模块化组件来创建优雅的用户界面。\n==AWT是重量级组件，操作系统不同表现不同。Swing组件不受影响，以J开头的组件都为swing组件==\n窗口\n窗口是GUI编程的基础，==Java提供的JFrame类的实例是一个底层容器==，即通常所说的窗口。==其他组件必须被添加到底层容器中==，以便借助这个底层容器和操作系统进行信息交互。\nApplet窗口：Applet类管理这个窗口，当应用程序程序启动时，由系统创建和处理；\n框架窗口(JFrame)：这是通常意义上的窗口，它支持==窗口周边的框架、标题栏，以及最小化、最大化和关闭按钮==；也是container的间接子类，但需要一个窗口时，可使用JFrame或子类创建一个对象\n一种无边框窗口(JWindow)：没有标题栏，没有框架，只是一个空的矩形。\n\nFrame类的主要构造方法：\nJFrame()：创建无标题的窗口对象；\nJFrame(String s)：创建一个标题名是字符串s的窗口对象。\nJFrame类的其他常用方法：\n**setBounds(int x,int y,int width,int height)：**参数x,y指定窗口出现在\n屏幕的位置；参数width,height指定窗口的宽度和高度。单位是像素。\n**setSize(int width,int height)：**设置窗口的大小，参数width和height指定窗口的宽度和高度，单位是像素。\nsetLocation(int x,int y)：设置窗口位置，默认位置是（0，0）\nsetVisible(boolean b):设置窗口是否可见，窗口默认不可见，true 可见，false 不可见\nsetReaizable(boolean b):设置窗口是否可调整大小，窗口默认可调整dispose（）：撤销当前窗口，并释放当前窗口所需要的资源setExtendedState(int state)：设置窗口的拓展状态\nMAXIMIZED_HORIZ（水平方向最大化）\nMAXIMIZED_VERT（垂直方向最大化）\nMAXIMIZED_BOTH（水平、垂直方向最大化）\nsetDefaultCloseOperation(int operation)：该方法用来设置单击窗体右上角的关闭图标后，程序会做出怎么样的处理，其中参数取下列int型的static的常量，程序根据参数operation取值作出不同处理\nDO_NOTHING_ON_CLOSE（什么也不做）\nHIDE_ON_CLOSE（隐藏当前窗口）\nDISPOSE_ON_CLOSE（隐藏当前窗口，并释放窗体占有的其他资源）\nEXIT_ON_CLOSE（结束窗口所在的应用程序）\nsetBackground(Color c)：以参数 c设置窗口的背景颜色。\nsetForeground(Color c)：设置前景色为 c\nvid setTitle(String title)：设置窗口中的标题\n\n\n*字段摘要*\n*颜色*\n\n\n\n\nstatic Color black/BLACK\n黑色\n\n\nstatic Color blue/BLUE\n蓝色\n\n\nstatic Color cyan/CYAN\n青色\n\n\nstatic Color darkGray/DARK_GRAY\n深灰色\n\n\nstatic Color gray/GRAY\n灰色\n\n\nstatic Color green/GREEN\n绿色\n\n\nstatic Color lightGray/LIGHTGRAY\n浅灰色\n\n\nstatic Color magenta/MAGENTA\n洋红色\n\n\nstatic Color orange/ORANGE\n桔黄色\n\n\nstatic Color pink/PINK\n粉红色\n\n\nstatic Color red/RED\n红色\n\n\nstatic Color white/WHITE\n白色\n\n\nstatic Color yellow/YELLOW\n黄色\n\n\n*菜单条、菜单、菜单项*\n1、菜单条（JComponent类的子类JMenubar）\nFrame类中将菜单条放置到窗口中的方法：setMenuBar(MenuBar bar);该方法将菜单条添加到窗口的顶端。注意：只能向窗口添加一个菜单条。\n2、菜单（JComponent类的子类JMenu）\nMenu()：建立一个空标题的菜单。\nMenu(String s)：建立一个指定标题s的菜单。\npublic void add(MenuItem item)：向菜单添加菜单项item。\npublic void add(String s)：向菜单增加指定的选项。\npublic MenuItem getItem(int n)：得到指定索引处的菜单项。\npublic int getItemCount()：得到菜单选项数目。\npublic void insert(MenuItem item,int n)：在菜单的指定位置插入菜单选项。\npublic void insert(String s,int n)：在菜单指定位置插入菜单选项。\npublic void remove(int n)：删除菜单指定位置的菜单选项。\npublic void removeAll()：删除菜单的所有选项。\n3、菜单项（JComponent类的子类JMenuItem）\nMenuItem()：构造无标题菜单项。\nMenuItem(String s)：构造有标题菜单项。\npublic void setEnabled(boolean b)：设置当前菜单项是否可被\n选择。\npublic String getlabel()：得到菜单选项的名字。\npublic void addActionListener(ActionListener):向菜单项增加监视器，从菜单项接收行动事件（单击菜单项）。\n4、嵌入子菜单\nJMenu是JComponent类的子类，因此菜单本身也是一个菜单项，当把一个菜单看作菜单项添加到某个菜单中时，称这样的菜单为子菜单\n5、菜单上的图标\n为了使一个菜单上有一个图标，可以用图标类Icon声明一个图标，使用ImageIcon类创建一个图标\nIcon icon = new ImageIcon（“a.gif”);\n然后菜单项调用setIcon（Icon icon）方法将图标设置为icon\nmenu1.addSeparator();  //分割线\n![img](file:///C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\ksohtml2496\\wps28.jpg)\n![img](file:///C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\ksohtml2496\\wps29.jpg)\n*添加图片要添加文件夹 再用文件夹的地址*\n![img](file:///C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\ksohtml2496\\wps30.jpg)\n*常用组件*\n常用组件都是JComponent的子类\nJTextField:文本框：允许用户输入单行文本\nJTextArea:文本区：允许用户输入多行文本\nJButton：按钮：单击 按钮\nJLabel：标签：为用户提供提示信息\nJCheckBox：复选框：为用户提供多项选择，有选中与未选中两种状态\nJRadioButton：单选按钮：为用户提供单项选择\nJComboBox：下拉列表：单项选择\nJPasswordField：密码框，默认显字符是*，可通过setEchoChar\n(char c)重新设置显字符\n![img](file:///C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\ksohtml2496\\wps31.jpg)\n![img](file:///C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\ksohtml2496\\wps32.jpg)\n*常用容器*\nJcomponent是Container的子类，其创建的组件也是容器，容器经常用来添加组件，Jframe是底层容器，本届提到的容器被习惯的称作中间容器，中间容器必须添加到底层容器才能发挥作用\n1、JPanel面板：默认是FlowLayout布局，可以向面板中添加组件，再把面板添加到其他容器中\n2、JScrollPane：滚动窗格，可以将文本区放在滚动窗格中\nJScrollPane jScrollPane=new JScrollPane(new TextArea())\n3、JSplitPane：拆分窗格，可分为左右或上下两部分,有两个构造方法：\nJSplitPane(int a,Component b,Component c)\n//参数a决定时水平还是垂直：HORIZONTAL_SPLIT，VERTICAL_SPLIT\n如  JSplitPane jSplitPane=new JSplitPane(JSplitPane.VERTICAL_SPLIT,new JButton(),new JButton())\nJSplitPane(int a,boolean d,Component b,Component c)\n//参数d是决定拆分线移动时，组件是否连续变化，true是连续\n4、JLayeredPane：分层窗格\nadd（Jcomponent com，int layer）;添加组件com，并指定com所在的层\nsetLayer(Component c，int layer)可以设置组件c所在的层\ngetLayer(Component c)可以获取组件c所在的层数\n*常用布局*\n1、FlowLayout布局（流式布局） 左到右 上到下\n（一）创建布局对象 FlowLayout flow = new FlowLayout（），其对\n象调用相应的方法可以重新设置布局的对齐方式\n（二）容器con使用布局对象 con.setLayout（flow）\n（三）Con可以使用Container类提供的add方法将组建顺序的添加到容器中\n2.BorderLayout布局（边界布局） 东南西北中\n（一）其布局是window型容器的默认布局\n（二）使用BorderLayout布局的容器con，可以使用add方法将一个组件b添加到中心区域\nCon.add（b，BorderLayout.CENTER）或\nCon.add（BorderLayout.CENTER，b）\n3、CardLayout布局（卡片布局）\n（一）创建布局对象\n（二）容器con使用布局对象\n（三）容器调用add（String s ，Component b）将组件b添加到容器，并给出了现实该组件代号s\n（三）布局对象card用CradLayout类提供的show（）方法，显示容器con中组件代号为s的组件 card.show（con，s）；\n4.GridLayout布局（网格布局）\n（一）创建布局对象，行m列n  GridLayout gird = new GridLayout（10，8）\n（二）容器调用add（Component c）将组件c加入容器中\n5.null布局（空布局）\n可以准确定位组件在容器的位置和大小，组件调用setBounds（int a，int b，int width，int height）方法可以设置本身的大小和在容器中的位置\n*JTabbedPane（选项卡面板）*\n![img](file:///C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\ksohtml2496\\wps33.jpg)\n常用构造方法:\ntabPlacement: 选项卡标题的位置, 值为 JTabbedPane.TOP、JTabbedPane.BOTTOM、 JTabbedPane.LEFT 或 JTabbedPane.RIGHT, 默认为 TOP\ntabLayoutPolicy: 选项卡位置不能放入所有的选项卡时，放置选项卡的策略，值为 JTabbedPane.WRAP_TAB_LAYOUT 或 JTabbedPane.SCROLL_TAB_LAYOUT\nJTabbedPane()\nJTabbedPane(int tabPlacement)\nJTabbedPane(int tabPlacement, int tabLayoutPolicy)\n创建选项卡:\ntitle: 选项卡的标题\nicon: 选项卡的图标\ntip: 当鼠标移到该选项卡时，悬浮提示的文本\ncomponent: 选中该选项卡时显示的内容组件\nvoid addTab(String title, Component component)\nvoid addTab(String title, Icon icon, Component component)\nvoid addTab(String title, Icon icon, Component component, String tip)\n在指定索引位置插入一个选项卡\nvoid insertTab(String title, Icon icon, Component component, String tip, int index\n移除选项卡:\n移除指定位置的选项（下面两个方法完全一致）\nvoid removeTabAt(int index)\nvoid remove(int index)\n移除指定内容控件的选项卡\nvoid remove(Component component)\n移除所有选项卡\nvoid removeAll()\n选项卡相关操作:\n设置当前选中的选项卡\nvoid setSelectedIndex(int index)\n获取当前选中的选项卡索引\nint getSelectedIndex()\n获取当前选中的选项卡对应的内容组件\nComponent getSelectedComponent()\n设置 index 位置的选项卡的标题\nvoid setTitleAt(int index, String title)\n设置 index 位置的选项卡的图标\nvoid setIconAt(int index, Icon icon)\n设置 index 位置的选项卡是否可用\nvoid setEnabledAt(int index, boolean enabled)\n将 index 位置的内容组件设置为 component\nvoid setComponentAt(int index, Component component)\n获取选项卡的数量\nint getTabCount()\n自定义选项卡标题位置的组件, 这里的 titleComponent 将放到选项卡标题位置。\n应用场景: 例如, 在选项卡标题位置添加一个关闭按钮, 点击按钮移除选项卡。\nvoid setTabComponentAt(int index, Component titleComponent)\n状态监听器:\n添加选项卡选中状态改变的监听器\nvoid addChangeListener(ChangeListener l)\n","plink":"http://example.com/2021/05/22/窗口组件/"},{"title":"多线程","date":"2021-05-16T07:15:27.872Z","date_formatted":{"ll":"2021年5月16日","L":"2021/05/16","MM-DD":"05-16"},"updated":"2021-05-16T07:28:17.588Z","content":"1、概念\n多任务\n边吃饭边看手机，看起来是多个任务，但在同一时间里只做了一件事情\n多线程\n原来只有一条车道，慢慢因为车多了，道路堵塞，效率降低，因此开辟了一条道路\n普通方法和多线程\n\n进程（process）和线程（Thread）关系\n==一个进程可以有多个线程，==如视频中同时听到声音，看到图片，看弹幕等。==一个进程至少有一个线程，线程是CPU调度和执行的单位==\n很多多线程是模拟出来的，==真正的多线程是多个CPU，即多核，如服务器==\n==程序==：是指令和数据的有序集合，其本身没有，任何运行的含义，是一个==静态==的概念\n==进程==：是执行程序的一次执行过程，是一个==动态的概念，是系统资源分配==的单位\n核心\n1、线程是==独立的执行路径==\n2、在程序运行时，后台会有==多个路径，如主线程和gc线程==（即垃圾回收进程）\n3、==main（）称之为主线程，为系统的入口==，用于执行整个程序\n4、在一个进程中，如果开辟了多个线程，==线程的运行由调度器安排，调度器与操作系统相关，先后顺序是不能人为的干预的==\n5、对同一份资源操作时，会==存在资源抢夺问题，需要加入并发控制==\n6、==线程会带来额外的开销==，如Cpu调度时间，并发控制开销\n7、每个线程在自己的工作内存交互，==内存控制不当会造成数据不一致==\n2、线程的创建\nThread class    继承Thread类（重点）-------API\nRunnable 实现Runnable接口（重点）\nCallable  实现Callable接口（了解）\nThread class\n==继承Thread类，重写run方法，创建对象，调用start（）==方法启动\n==start（）使得交替执行，没有先后顺序==\nRunnable\n==一个类继承该接口，重写run方法，创建该类的对象，将Thread实例化并赋给它，再用start==\nThread方法\n1public static Thread currentThread()\n返回对当前正在执行的线程对象的引用。\n12public static void sleep(long millis)                  throws InterruptedException\n使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。 线程不会丢失任何显示器的所有权。\n小结\nThread：1、子类继承Thread类具备多线程能力\n​                 2、启动线程：子类对象.start（）\n​                 3、==不建议：避免OOP单继承局限性==\nRunnable：1、实现Runnable具有多线程能力\n​                     2、启动线程：传入目标对象+Thread对象.start（）\n​                     3、推荐：避免单继承局限性，灵活方便，方便同一个对象被多\n​                           个线程使用\n实现Callable接口（了解）\n1、==实现Callable接口==，需要返回值类型\n2、==重写call方法==，需要抛出异常\n3、创建目标对象\n4、创建执行服务  ExecutorService ser=Executors.newFixedThreadPool(线程个数);\n5、提交执行：Futureresult1=ser.submit（线程名称）\n6、获取结果：boolean r=result1.get（）\n7、关闭服务：ser.shutdownNow();\n\nCallable好处\n1、可以定义为返回值\n2、可以抛出异常\n静态代理（进程的实现原理）\n你：真实角色\n婚庆公司：代理你，帮你处理结婚的事情\n结婚：实现结婚的接口\n总结\n真实对象和代理对象都要实现同一个接口，代理对象要先代理真实角色\n好处\n代理对象可以实现很多真实对象做不了的事情\n真实对象专注做自己的事情\nLamda表达式\n定义：\n==任何接口，如果只包含唯一一个抽象方法==，那么他就是一个函数式接口\n12345public interface Runable&#123;     public abstract void run（）；&#125;\n对于函数式接口，我们可以通过lamda表达式来创建该接口的对象\n==最普通 静态内部类 局部内部类  匿名内部类  拉姆达类==\n好处\n避免匿名内部类定义过多\n其实质属于函数式编程的概念\n对象=（）-&gt;{…}\n==带有参数==\n1、直接代入\n2、参数类型删去\n3、删去括号\n4、删去花括号，==但只能是一条语句==（以上可以一起执行）\n5、==有多个参数类型。去掉参数，用逗号隔开且用括号括====起来==\n3、线程状态-\n\n1000毫秒=1秒\n停止线程\n1、推荐线程自己停止下来\n2、建议使用一个标志位进行终止变量，当flag=false，则终止线程运行\n3、不推荐使用JDK提供的stop（）、destroy（）方法\n步骤\n1、设置标识符\n2、设置一个公开方法停止线程，转换标识符\n3、调用stop方法切换标识符，让线程停止\n线程休眠sleep\n1、sleep指定当前线程阻塞的毫秒数\n2、sleep存在异常interruptedException\n3、sleep时间达到后线程进入就绪状态\n4、sleep可以模拟网络延时、倒计时\n5、每一对象都有一把锁，sleep不会释放锁\n线程礼让yield\n1、礼让线程，让当前正在执行的线程暂停，但不阻塞\n2、将线程从运行状态变为就绪状态\n3、让cpu重新调度，礼让不一定成功，看CPU心情\n线程合并join\n1、join合并线程，待此线程执行完成后，在执行其他线程，其他线程阻塞\n2、可以想象成插队，执行完插队的内容，在执行主线程\n线程状态监测\nNEW 尚未启动线程\nRUNNABLE 在Java虚拟机执行的线程处于此状态\nBLOOKED 被阻塞\nWAITING  正在等待另一个线程执行特定的动作处于此状态\nTIMED WAITING 正在等待另一个执行动作达到指定等待时间的线程处于此状态\nTERMINATED\n已退出的线程\n线程优先级\n1、Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行\n2、线程的优先级用数字来表示，范围1到10\nThread.MIN_PRIORITY=1\nThread.MAX_PRIORITY=10\nThread.NORN_PRIORITY=5\n3、使用以下方式改变或获取优先级\ngetPority setPriority(int xxx)\n4、从数字高的先执行（但还是得看CPU调度）\n**优先级设定必须在\n守护（daemon）线程\n1、线程分为用户线程和守护线程\n2、虚拟机必须确保用户线程执行完毕 main\n3、虚拟机不用等待守护线程执行完毕   gc\n4、true为用户线程 false为守护线程\n如：后台记录操作日志，监控内存，垃圾回收\n4、线程同步机制\n==并发：同一个对象被多个线程同时操作==  例如：两个银行同时取钱\n现实生活中，遇到同一个戏院多个人想同时使用，比如食堂排队，每个人先吃饭，最简单的方式:排队\n处理多个线程问题，多个线程访问同一个对象时，并且某些线程还想修改这个对象，这时候我们就需要线程同步，线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程在使用\n形成条件：队列+==锁==\n由于同一进程的多个线程同时共享同一块存储空间，在带来方便的同时，也也带来访问冲突问题。为了保证数据在方法中被访问时的正确性，在访问时加入锁机制 ==synchronized== ，==当一个线程获得对象的锁。独占资源。其他线程笔其他对象必须等待，使用后释放锁即可，但存在以下问题：\n1、一个线程持有索会导致其他所有需要此锁的线程挂起\n2、在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延迟，引起性能问题\n3、如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题。比如：上大号和小号，性能低大号上厕所，小号性能高会等待的久\n同步synchronized\nsynchronized方法和synchronized块\n同步方法\npublic synchronized void method（int  args）{}\nsynchronized方法控制对象的访问，每个对象对应一把锁，每个==synchronized==**方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞。方法一旦调用，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程。**缺陷：==将一个大的方法声明为synchronized将会影响效率==\n同步块\nsynchronized（Obj）{}\n==Obj称为同步监视器，锁变化的量==\n**Obi可以是任何对象，**但是推荐使用共享资源作为同步监视器\n同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class【反射中讲解】\n同步监视器的执行过程：\n1、第一个线程访问，锁定同步监视器，执行其中代码\n2、第二个线程访问，发现同步监视器被锁定，无法访问\n3、第一个线程访问，解锁同步监视器\n4、第二个线程访问，发现同步监视器没有被锁定，然后锁定并访问\njuc安全集合\n==CopyOnWriteArrayList==所建立的对象是安全的\n5、死锁\n多个线程各自站有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，==某一个同步块同时拥有”两个以上对象的锁“时，就可能会发生”死锁“问题==\n例如：拿了这个锁，但还想要另一个所，但一个人只能有一个锁\n产生死锁的四个必要条件\n1、互斥条件：一个资源每次只能被一个进程使用\n2、请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放\n3、不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺、\n4、循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系\n==只要想办法破其中的任意一个或多个条件就可以避免死锁发生==\n6、Lock锁\n1、通过显示定义同步锁对象来实现同步，同步锁使用了Lock对象充当\n2、java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具，锁提供了对共享资源空间的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享对象之前先获的Lock对象\n3、ReentrantLock类实现Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的时ReentrantLock，可以显示加锁、释放锁\n12345678910111213class A&#123;   private final ReentrantLock lock&#x3D;new ReentratrLock();   public void m()&#123;   \t lock.lock();     try&#123;          &#125;     finally&#123;       lock.unlock();       &#x2F;&#x2F;如果同步代码块有异常，将unlock（）写入finally语句块     &#125;   &#125;&#125;\nSynchronized和Lock的对比\n==1、Lock是显示锁（手动开启和关闭锁），synchronized是隐式锁，出了作用域自动释放==\n2、Lock只有代码块锁，synchronized有代码块锁和方法锁\n3、使用Lock锁，JVM将花费较少的时间调度线程，性能更好，并且具有更好的拓展性\n优先使用顺序：Lock&gt;同步代码块（已经进入了方法体，分配了相应资源）&gt;同步方法(在方法体之外)\n7、线程通信\n分析：这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件\n1、对于生产者，没有生产产品之前，要通知消费者等待，而生产了产品之后，又需要马上通知消费者消费\n2、对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费\n==3、在生产者消费者问题中，仅有synchronized是不够的==\n​      ==synchronized可阻止并发更新同一个共享资源，实现了同步==\n​      ==synchronized不能用来实现不同线程之间的消息传递（通信）==\n方法\nwait（） 表示线程会一直等待，知道其他线程通知，与sleep不同，会释放锁\nwait（long times）指定等待的毫秒数\nnotify（）唤醒一个处于等待状态的线程\nnotifyAll（）唤醒同一个对象上所有调用wait（）方法的线程，优先级别高的线程优先调查\n均为Object类的方法，==都只能在同步方法或者同步代码块中使用==，否则会抛出异常IllegalMonitorStateException\n解决\n（1）并发协作模型”生产者/消费者模式“-&gt;管程法\n生产者：负责生产数据的模块（可能是方法，对象，线程，进程）\n消费者：负责处理数据的模块（可能是方法，对象，线程，进程）\n缓冲区：消费者不能直接使用生产者的数据，它们之间有个”缓冲区“\n==生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据==\n（2）并发协作模型”生产者/消费者模式“-&gt;信号灯法\n类似于”停止线程“\n注意\nsleep（） wait（）有try catch\n8、线程池\n背景：经常创建和销毁，使用量特别大，比如出现并发情况下的线程，对性能影响很大\n思路：提前创建好多个线程，放入线程池中，使用是直接获取，使用完放回池子中，可以避免频繁创建销毁、实现重复利用，类似交通工具\n好处：提高响应速度，降低资源耗损，便于线程管理\n方法：corePoolSize：核心池的大小\n​            maximumPoolSize：最大线程数\n​             keepAliveTime：线程没有任务时最多保持多长时间会终止\nExecutorService：真正线程池接口\n​                                 常见子类；void excute（Runnable command）——执\n​                                                    行命令，没有返回值\n​\t\t\t\t\t\t\t\t\t\t\t\t\tFuturesubmit(Callabletask)——\n​                                                    执行命令，有返回值\n​                                                    void  shutdown()——关闭连接池\nExecutors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池\n","plink":"http://example.com/2021/05/16/多线程/"},{"title":"Hello World","date":"2021-02-02T09:59:38.499Z","date_formatted":{"ll":"2021年2月2日","L":"2021/02/02","MM-DD":"02-02"},"updated":"2021-02-07T09:53:46.166Z","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n\nQuick Start\nCreate a new post\n1$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server\n1$ hexo server\nMore info: Server\nGenerate static files\n1$ hexo generate\nMore info: Generating\nDeploy to remote sites\n1$ hexo deploy\nMore info: Deployment\n","plink":"http://example.com/2021/02/02/hello-world/"}]