[{"title":"数据库","date":"2021-03-16T13:11:36.800Z","date_formatted":{"ll":"2021年3月16日","L":"2021/03/16","MM-DD":"03-16"},"updated":"2021-03-15T12:29:20.497Z","content":"一、什么是SQL？\nSQL 是结构化查询语言 Structured Query Language 的缩写，用来访问和操作数据库系统。SQL 语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还可以对数据库进行管理和维护操作。不同的数据库，都支持 SQL，这样，我们通过学习 SQL 这一种语言，就可以操作各种不同的数据库。\nSQL定义了这么几种操作数据库的能力：\nDDL：Data Definition Language\n允许用户定义数据，也就是创建表、删除表、修改表结构这操作。通常，DDL由数据库管理员执行。\nDML：Data Manipulation Language\n为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。\nDQL：Data Query Language\n允许用户查询数据，这也是通常最频繁的数据库日常操作。\n即：\nDDL-定义数据（增删表，修改表结构）\nDML-管理数据（增删改数据）\nDQL-查询数据\n二、MySQL\nMySQL是目前应用最广泛的开源关系数据库，所使用的 SQL 语言是用于访问数据库的最常用的标准化语言，其特点为体积小、速度快、总体拥有成本低，尤其是开放源码这一特点。\n==mysql的端口号一定为3306==\n==comment==\n1、是备注、注释的意思\n2、COMMENT 'id’删除不会影响数据操作，只是没有字段注释说明，通常字段或列名都需要加注释，以方便自己和其他同事阅读数据库表字段信息。\n3、在MySQL数据库中，字段或列的注释是用属性comment来添加。\n创建新表添时，填加comment注释的示例代码如下：\ncreate table test(id int not null default 0 comment ‘用户id’);\n三、关系数据库管理系统(Relational Database Management System)的特点：\n1.数据以表格的形式出现\n2.每行为各种记录名称\n3.每列为记录名称所对应的数据域\n4.许多的行和列组成一张表单\n5.若干的表单组成database（数据库）\n基本概念\n*数据库:* 数据库是一些关联表的集合。\n*数据表:* 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。\n*列:* 一列(数据元素) 包含了相同类型的数据, 例如邮政编码的数据。\n****行：****一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。\n*冗余*：存储两倍数据，冗余降低了性能，但提高了数据的安全性。\n*主键*：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。\n****外键：****外键用于关联两个表。\n*复合键*：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。\n****索引：****使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。\n*参照完整性:* 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。\n![img](file:///C:\\Users\\Administrator\\AppData\\Local\\Temp\\ksohtml13072\\wps1.jpg)\n*表头(header)*: 每一列的名称;\n*列(col):* 具有相同数据类型的数据的集合;\n*行(row)*: 每一行用来描述某条记录的具体信息;\n*值(value)*: 行的具体信息, 每个值必须与该列的数据类型相同;\n*键(key)*: 键的值在当前列中具有唯一性。\n四、使用终端操作数据库 （命令后加；）\n1、如何登录数据库服务器\nmysql  -uroot  -p登陆密码（登陆本机）\nMysql  -h主机名 -p端口名  -u用户名  -p登陆密码\n2、退出\nexit 或ctrl+c\n3、如何查询数据库服务器中的数据库\nshow database；\n![img](file:///C:\\Users\\Administrator\\AppData\\Local\\Temp\\ksohtml13072\\wps2.jpg)\n4、如何选中一个数据库进行操作\nuse 数据库\nShow tables 从当前数据库查看信息\n![img](file:///C:\\Users\\Administrator\\AppData\\Local\\Temp\\ksohtml13072\\wps3.jpg)\nshow tables from 数据库名 可从别的数据库查看别的数据库信息\nselect database(); 查看当前所在数据库\n![img](file:///C:\\Users\\Administrator\\AppData\\Local\\Temp\\ksohtml13072\\wps4.jpg)\n5、创建表和列\ncreate table + 表名（\n再是列的种类\n若是结束了也用）；结尾\n6、查看表的内容\ndesc +表名\n![img](file:///C:\\Users\\Administrator\\AppData\\Local\\Temp\\ksohtml13072\\wps5.jpg)\n7、查看表的数据\nselect * from +表名\n![img](file:///C:\\Users\\Administrator\\AppData\\Local\\Temp\\ksohtml13072\\wps6.jpg)\n8、表中插入数据\nInsert into +表名（数据类型）value+（内容）\n![img](file:///C:\\Users\\Administrator\\AppData\\Local\\Temp\\ksohtml13072\\wps7.jpg)\n9、修改数据\nupdate 表名 set 数据类型 = ’修改内容‘ where 数据类型 = 内容\n![img](file:///C:\\Users\\Administrator\\AppData\\Local\\Temp\\ksohtml13072\\wps8.jpg)\n10、删除数据\ndelete from stuinfo where内容；\n![img](file:///C:\\Users\\Administrator\\AppData\\Local\\Temp\\ksohtml13072\\wps9.jpg)\n11、查看数据库版本\n登录到mysql服务器：select version();\n没有登陆：mysql --version/mysql --V\n![img](file:///C:\\Users\\Administrator\\AppData\\Local\\Temp\\ksohtml13072\\wps10.jpg)\n12、mysql语法规范\n不区分大小写，但建议==关键字大小，表名列名小写,每条命令分号结尾，根据需要可以进行缩进，换行==\n![img](file:///C:\\Users\\Administrator\\AppData\\Local\\Temp\\ksohtml13072\\wps11.jpg)\n注释 单行：#注释文字  - - 注释文字\n​        多行：/注释文字/\n五、sql语言\n分为DQL语言、DML语言、DDL语言、TCL语言\nDQL语言\n1、基础查询\n==select+查询列表 from+表名；显示什么==\n类似于system.out.print()打印什么\n特点：1、查询列表可以是：表中的字段、常量值、表达式、函数\n​           2、查询的结果是一个虚拟的表格\nuse 启动的数据库名；\n#查询单个字段 select 字段名 from 对应的表名；\n#查询表中的多个字段 select 字段名，字段名… from 对应的表名；\n#查询表中的所有字段\nselect 字段名，字段名… （可直接双击左边数据库的字段名，会按选择顺序显示）from 对应的表名；\nselect * from 对应的表名；\n查询表中的常量值，只要是字符用双引号 select 100；\n查询表中的表达式 select 100%98；\n查询表中的函数（方法） select version();\n起别名（方便理解）\n方式一，用as\nselect 100&amp;98 As 别名；\n方式二，用空格\nselect 100&amp;98 别名，first 别名 from 对应的表名；\n去重distinct\n案例：查询员工表中涉及的所有部门编号\n​\tselect distinct department from 对应的表名；\n+号的作用  运算符，两个操作数都是数值型\nselect 100+90 190\nselect ‘123’+90  213  ==其中一方为字符串，试图将字符型数值转换成数值型，如果转换成功，则继续做加法运算==\nselect ‘join’+90  90 如果转换失败，则返回原始数据\nselect null+90 90 只要其中一方为null ，则结果显示为null\n案例：查询员工名和姓连接成一个字段，并显示为姓名\nselect concat(‘a’,‘b’,‘c’) As 别名from 对应的表名\n==查询数据库，如果字段名为空，返回0==\n==select ifnull(‘字段名’，0)  As 别名 from 对应的表名==\n条件查询\n语法：==select 查询列表 from 表名 where 筛选条件；（条件成立即可过滤出来）==\n分类：按条件运算符 &lt;  &gt;  =  !=  &lt;&gt;也为不等 &gt;=  &lt;=\n​            按逻辑运算符 &amp;&amp;  ||  ！用于链接条件表达式\n​            模糊查询  like  特点：和通配符搭配 ，\n==%任意多个字符，包含0个字符==\n==_任意单个字符==\nbetween and 特点：提高简洁读 包含临界值  要从小到大排序\nin 特点：用于去判断某字段的值是不是in列表里的值\n​                字段的值要同种类型\nis null特点：=或&lt;&gt;（不等于）不能用于判断null值\n查询工资高于12000的员工：\nselect * from  employee  where salary&gt;12000\n逻辑运算符\n查询工资在12000到15000的员工：\nselect * from  employee  where salary&gt;12000 &amp;&amp;salary &lt;15000\n==模糊查询 like 像==\n（条件不是特别具体）\nselect * from  employee  where  name like ‘%a%’（%代表通配符）\n查询员工名包含第三个字符e，第五个字符为a的员工（条件不是特别具体）\nselect * from  employee where  name like‘__e_a%’（_代表字符个数）\n查询员工名包含第二个字符_的员工（条件不是特别具体）\nselect * from  employee where  name like‘__%’ escape  ‘\\’（任意符号都可代表转义，用escape）\n==between and 在…之间==\n查询员工编号在100到200之间\nselect * from  employee  where  id&gt;100 &amp;&amp; id &lt;200  ==\nselect * from  employee id  where  id  between  100  and  200\n==In 用于去判断某字段的值是不是in列表里的值==\n查询员工工种编号是IT 、AD中的一个员工编号\nselect * from  employee id  where  job id = ‘IT’|| job id = ‘AT’\n== select * from  employee  id  where  job id in（‘IT’‘AT’）\n==is null 只可以判断null值==\n查询没有（有）奖金的员工名和奖金率\nselect * from  employee id  where  comsionn  is  (not )null\n==安全等于 &lt;=&gt; 判断普通类型的值，判断是否等于，等于返回==\n查询没有（有）奖金\n排序查询\n==引入：select * from  employee id  显示原始的数据====\n当我们要按工资的高低先后显示出来\n可直接在图形化界面直接点那个表头就可以排序\n用sql语句：select  查询列表 from 表 【where筛选条件】====order\n​                        ** by****支**  持 别名）排序列表【ascldesc】====\n特点: 高到低：desc   低到高：asc  不写默认是低到高\norder by 可以支持多个字段、单个字段、表达式、函数、别名\norder by 一般放在查询语句最后面，limit的子句除外\n查询员工工资从高到低：\nselect * from  employee  order by  salary desc；\n查询部门编号大于等于90的员工信息，按入职时间先后进行排序\nselect * from employee where department_id&gt;=90 order by hirdate asc;\n按年薪高低显示员工年薪和信息（表达式）\nselect ，salary12*(1+ifnull(commission_pat,0) 年薪 from employee order by salary12(1+ifnull(commission_pat,0)/年薪 asc;\n按姓名长度显示员工姓名和工资（函数）\nselect  length（last_name),last_name,salsry from employee order by length（last_name)  asc;\n查询员工信息，先按工资排序，再按员工编号排序（多个字段）：\nselect * from  employee  order by  salary  asc，employee_id desc；\n常见函数\n功能:类似于java中的方法，具备的含义将实现某个功能的逻辑语句封装到一个方法中，对外暴露方法名\n好处：隐藏功能的实现细节，提高代码的重用性\n==调用：select 函数名（实参列表）  【from  表】==\n特点：该方法叫什么（函数名）  干什么（函数功能）\n分类：单行函数： 做处理  一个返一个\n分组函数： 做统计使用，又为统计函数、聚合函数、组函数  多个返一个\n==单行函数：字符、数学、日期、其他函数、流程控制函数==\n1、字节函数：\nLength获取参数的字节个数\nselect  length（‘join’)  返回4\nselect  length（‘张三丰hahaha’)  返回15 一个汉字占3个字节\nConcat拼接字符串\nselect  concat（last_name,_,first_name) 姓名from  employee\nUper、lower大写小写\nselect  Uper（‘join’） 返回JOIN\nselect  lower（‘JOIN’） 返回join\n将姓大写，名小写，拼接\nselect  concat （uper（last_name),lower（first_name）)from。。。。\nSubstr、substring 截取字符串，索引从1开始\nSelect  substr（‘李莫愁爱上了陆展源’，6）out_put; 返回了陆展源\nSelect  substr（‘李莫愁爱上了陆展源’，1，3）out_put; 返回李莫愁\nInstr返回第一次出现的起始索引\nSelect  Instr（‘李莫愁爱上了陆展源’，’陆展源‘）as out_put\nfrom  employee； 返回7，找不到返回0\ntrim 去前后\nSelect trim（‘a’ from ‘aaaaaa张aaaaaaa翠山aaaaaaaaaaaaaaaaa  ’）as out_put  返回张aaaaaaa翠山\nLpad 用指定字符左填充\nSelect  lpad（‘殷素素’ ，5，‘*’）as out_put  返回**殷素素\nrpad 用指定字符右填充\nSelect  rpad（‘殷素素’ ，5，‘*’）as out_put  返回殷素素**\nreplace 替换\nSelect  rpad（‘殷素素’ ，‘殷’，‘赵’）as out_put 返回赵素素\n1、数学函数：\nRound 四舍五入\nSelect  round（1.45）；先弄绝对值 再加正负号\nSelect  round（1.457，2）；小数点保留两位，返回1.46\nceil 向上取整，返回大于等于参数的最小整数\nSelect  ceil（1.45）； 返回2\nSelect  ceil（1.00）； 返回1\nFloor 向下取整，返回小于等于参数的最大整数\nSelect  floor（-9.99）； 返回-10\ntruncate截断，保留小数后几位\nSelect  truncate（1.65，1）； 返回1.6\nMod 取余，==被除数负数取余为负数，被除数正数取余为正数==\nMod（a，b）  语法：a- （a/b）*b\nSelect  mod（10，3）  10%3 返回1\n2、日期函数：\nNow 返回当前系统日期+时间\nSelect  now（）\ncurdate返回当前系统日期\nSelect  curdate（）\nCurtime返回当前系统时间\nSelect  curtime（）\n获取指定的年月日小时分钟秒\nSelect  year（now（））年；\nSelect  year（1999）年；\nSelect  month（now（））月\nSelect  month_name（now（））月\nStr_to_date将日期格式的字符转换成指定格式的日期\nStr_to_date（‘9-13-1999’，‘%m-%d-%Y）   1999-09-13\nDate_format:将日期转换成字符\nDate_format（‘2018/6/6’，‘%Y年%m月%d日） 2018年6月6日\n3、其他函数\nselect vesion（）查看当前数据库版本\nselect database（）查看数据库\nselect user（）查看用户\n4、流程控制函数\nSelect if（条件，ture表达式值，flse表达式值）\n案例：Select if（10&gt;5，大，小）\ncase函数：\n==使用一：类似于java的switch case的效果==\nMysql：\nCase（要判断的字段表达式）\nWhen常量值1 then 要显示的语句1；\nWhen常量值2 then 要显示的语句2；\n…\nElse 要显示的语句；\nEnd\n【可单独使用，也可搭配select】\n案例查询员工工资  部门号为30 显示的工资为原工资的1.1倍\n部门号为40 显示的工资为原工资的1.2倍\n其他员工资\nselect salary原始工资，department_id，\ncase  department_id\nWhen 30 then salary*1.1  （不是语句不放分号）\nWhen 40 then salary*1.2\nElse salary\nEnd as 新工资\nFrom employee\n==使用二：类似于java多重if==\nIf（条件1）{\n语句1；\n}else if（条件2）{\n语句2；\n}else {\n语句n；\n}\nMysql：\nCase\nWhen 条件1 then 值1或语句1；（是true）\nWhen 条件2 then 值2或语句2；（是true）\n​        …\nElse 要显示的值或语句\nEnd\n查询员工新工资\n如果工资&gt;20000，显示A级别\n如果工资&gt;15000，显示B级别\n如果工资&gt;10000，显示C级别\n否则，显示D\nselect salary原始工资，department_id，\nCase\nWhen  salary &gt;20000  then‘A’ （不是语句不放分号）\nWhen  salary &gt;15000  then ‘B’\nWhen  salary &gt;10000  then ‘C’\nElse ‘D’\nEnd as 新工资\nFrom employee\n分组函数\n==特点：1、sum、avg一般用于处理数值型==\n​            ==2、max、min、count、用于处理任何类型==\n​            ==3、分组函数都null没有参与运算==\n​           ==4、可以和distinct搭配，去重==\n​           ==5、和分组函数一同查询的字段有限制，要求是ground by的字段==\n​     select avg（salary）只有一个，employee_id很多 from employee\n1、Sum求和\n简单的使用  select sun（salary）from employee\n2、Avg平均值\n简单的使用  select avg（salary）from employee\n3、Max最大值  可支持字符、日期\n简单的使用  select max（salary）from employee\n4、Min最小值  可支持字符、日期\n简单的使用  select min（salary）from employee\n5、Count计算个数\nselect count（*/常量值/阿拉伯数字）from employee  统计行数\n效率——mysiam 存储引擎下，count（*）效率最高\n默认的引擎innoob，count（*）和count（1）效率差不都，但比count（字段）快\n==所以一般使用 count（*）统计行数==\n简单的使用  select count（salary）from employee\n结合：select sun（salary）， avg（salary），max（salary），\n​           min（salary），count（salary）from employee\n​          select sun（salary）， round(avg（salary），2)  max（salary），\n​           min（salary），count（salary）from employee\n==相差天数：datediff（晚，早）==\n引入：查询每个部门的平均工资\n==语法: group by字句语法==\n==Select 分组函数，列（要求出现在group by的后面）from 表==\n==where 筛选条件】group by 分组的列表【order by子句】==\n==注意：查询列表比较特殊，要求是分组函数和group by后出现的字段==\n（1）Group by语法可以根据给定数据列的每个成员对查询结果进行分组，这里的分组就是将一个**“数据集合”划分成若干个“小块”，然后对这些“小块”进行数据处理。最终得到按一个分组汇总的结果表。**\n（2）SELECT子句后面的字段一般是聚合函数或者是Group by 后面的。\n（3）Group by 一般和sum、max、avg等聚合函数一起使用。\n\n\n特点：\n1、条件分为两类，数据源不一样\n分组前筛选（原始表，库里面真实存在的）group by字句where\n分组后筛选（分组后的结果集）  group by字句后 having\n分组函数做条件是放在having子句中\n能用分组前筛选的，优先考虑使用分组前筛选\n2、group by字句支持的单个字段分组（多个字段之间用逗号\n​    隔开没有顺序要求），支持表达式和函数，用的比较少\n3、也可以添加排序（排序放在整个分组）\n每个工种的最高工资\nselect max（salary），job_id from employees group by job_id\n每个位置的部门个数\nselect count（*），location_id from department group by location_id\n查询邮箱中包含a字符的，每个部门的平均工资\nselect  avg（salary），department_id from employee where emails like\n‘%a%’ group  by  department_id\n查询有奖金的每个领导手下员工最高工资\nselect  max（salary），manager_id from employee where commission_pct  is  not null  group  by  manager_id\n查询哪个部门的员工个数大于2  分组后的筛选having\n#查询每个部门的员工个数\nselect count（*），department_id from employee group by departmentr_id\n#根据上述结果进行筛选，查询哪个部门的员工个数大于2\nselect count（），department_id from employee group by departmentr_id having count（）&gt;2\n查询每个工种有奖金的员工的最高工资大于12000的工种编号和最高工资\n#查询每个工种有奖金的员工的最高工资\nselect max（salsry），job_id from employee where comsion_pct is not null group by job_id\n#根据上述结果进行筛选，查询最高工资大于12000\nselect max（salsry），job_id from employee where comsion_pct is not null group by job_id having max（salsry）&gt;12000\n查询领导编号&gt;102的每个领导手下的员工最低工资大于5000的领导编号是哪个，以及最低工资\n#查询每个领导手下最低工资的员工\nselect min（salsry），manager_id from employee group by manager_id\n#查询编号&gt;102，最低工资大于5000\nselect min（salsry），manager_id from employee where manage&gt;102 group by manager_id having min（salsry）&gt;5000\n按员工姓名长度分组，查询每一组员工个数&gt;5的有哪些\n#查询每个长度的员工个数\nselect count（*），length（last_name）from employee group by length（last_name）\n#查询员工个数&gt;5\nselect count（），length（last_name）from employee group by length（last_name）having  count（）&gt;5\n查询一下每个部门每个工种的平均工资\nselect avg（*），department_id ，job_id from employee group by department_id ，job_id\n查询一下每个部门每个工种的平均工资大于1000，并且按平均工资高低显示出来\nselect avg（），department_id ，job_id from employee where department_id is not null group by department_id ，job_id having avg（）&gt;10000 order by  avg（*）desc\n连接查询\n含义：又称多表查询，当查询的字段来自于多个表时，就会用到连接查询\n笛卡尔集错误情况：select count（*）from beauty 假设输出12行\n​         select count（*）from boys 假设输出4行\n​         最终结果为 12*4=48\n如何发生：没有有效的连接条件\n避免发生：有有效的连接条件\n分类：按年代分类——sq192标准：仅仅支持内连接\n​          sq199标准：支持内连接+外连接（左外和右外）+交叉连接\n按功能分类——内连接：等值连接、非等值连接、自连接\n​                           外连接：左外连接、右外连接、圈外练就额\n​                            交叉连接\n一、sql192语法\n1、等值连接\n特点：夺标等值连接的结果为夺标的交集部分；n表连接，至少需要\n​           N-1个连接条件；多表的顺序没有要求；一般需要为表起别名；可以搭\n​           配所有的子句\n​                    Beauty                                                                boys\n\n\nId\nName\nSex\nBoyfried-id\nBoyname\nUsercp\n\n\n\n\n1\n柳岩\n女\n6\n黄晓明\n100\n\n\n2\n热巴\n女\n2\n鹿晗\n800\n\n\n3\n周芷若\n女\n3\n张无忌\n30\n\n\n4\n周冬雨\n女\n7\n\n\n\n\n5\n杨颖\n女\n1\n\n\n\n\n查询女神名和对应的男神名\nSelect name,boyfriend from boys,beauty where beauty.boyfriend_id =boys.id;\n查询员工名和对应的部门名\nSelect last_name,department_name from employee,departments where\nEmployee.department_id = department.department_id\n查询员工名、工种号、工种名 起别名提高简洁读\nSelect last_name,Employee.job_id，job_title  from employee e,jobs\nJ where e.job_id = j.Job_id\n==PS：两个表顺序可以互换==\n==运行代码都是先执行from 在执行select，若使用了别名，则用别名==\n查询有奖金的员工名、部门名\nSelect last_name,department_name from employee e,departments d where e.department_id = d.department_id and e.commission is not null\n查询城市名字第二个字符为o对应的城市名和部门名\nSelect department_name，city from departments d ，location l where\nD. location_id = l.location_id  and city like ‘_o%’\n查询每个城市的部门个数\nSelect count（*），city from departments d ，location l  where d.location id =l.location id group by city\n查询有奖金的部门名和领导编号和该部门的最低工资\nSelect department_name，manager_id ，min(salary) from departments d ，employee e where d.department_id = e.department_id and commission_pct is not null group by  department_name,d.manager_id\n查询每个工种的工种名和员工个数，并且按员工个数降序\nSelect job_title,count() from employee e,jobs j where e.job_id = j.job_id group by job_title order by count()desc\n查询员工名、部门名和所在的城市有s的字符\nSelect last_name,department_name ，city from employee e,departments d，location l where e.department_id = d.department_id and d.location_id = l.location_id and city like  ‘s%’\n2、非等值连接  数值不是等于，而是在两个数之间\n查询员工工资和工资级别\nSelect salary,grade_level from employee e,job_grades g where salary between g.lowest_sal and g.highest_sal\n3、自连接  自己连接自己\n查询员工名和上级的名字\nSelect e.last_name,e.employee_id m.last_name,m.employee_id from employeee e,employees m where e.employee_id=m.employee_id\n二、sql199语法\n==语法 : select 查询列表==\n==from 列表1 别名 【连接类型】==\n==join 列表2 别名 on 连接条件【where 筛选条件】==\n==【group by 分组】【having 筛选条件】【order by 排序列表】==\n分类:内连接:——inner\n外连接：左外——left 【outer】\n​               右外——rig ht【outer】\n​               全外——full【outer】\n交叉连接：cross\n==找谁谁就是主表==\n1、内连接 （查询交集部分）\n语法：select 查询列表\nfrom 列表1 别名 ==inner join== 列表2 别名 on 连接条件\n分类：等值连接、非等值连接、自连接\n特点：添加排序、筛选、分组\n==Inner可以省略==\n==筛选条件放where后面，连接条件放on后面，提高分离性，便于阅读==\n==#等值连接==\n查询员工名、部门名\nSelect last_name,department_name from employee e inner join departments d on e.department_id = d.department_id\n查询名字中包含e的员工名和工种名\nSelect last_name,join_title from employee e inner join jobs j on e.job_id = j.job_id where e.last_name like “%e%”\n查询部门个数&gt;3的城市名和部门个数（添加分组和筛选）\nSelect city,count()部门个数 from departments d inner join location l  on d.location_id = l.location_id group by city having count()&gt;3\n查询哪个部门的员工个数&gt;3的部门名和员工个数，并按个数降序（添加排序）\nSelect count()部门个数 ，departments_id from employee inner join departments d on e.department_id = d.department_id group by departments_name having count()&gt;3 order by count(*) desc\n查询员工名、部门名、工种名、并按部门名降序（）\nSelect last_name，departments_name，job_title  from employee e inner join departments d on e.department_id = d.department_id  inner join jobs j on e.jobs_id = j.jobs_id  order by departments_name desc\n2、外连接（用于查询一个表中，另一个表没有的记录）\n特点：1==、如果从表中有和他匹配的，则显示匹配的值==\n==如果从表中没有和他匹配的，则显示null==\n==外连接查询结果=内连接结果+主表中有而从表没有的==\n2、左外连接：left join 左边的是主表  右外连接：right join右边的是主表\n3、左外和右外交换两个表的顺序，可以实现同样的效果如果\n用beauty匹配boys表，则beauty表为主体表，boys为从表，主表不变，从表填充\n4、全外连接=内连接结果+表1中有但表2中没有的+表2中有但表1中没有的\n查询男朋友不在男神表的女神名\n左外：select b.name from beauty b left outer join boys bo on b.’noyfriend_id’=bo.’id’ where bo.’id’ is null\n查询哪个部门没有员工\n左外：select d.*,e.employee_id  from department d left outer join employees e on d.’department_id’=e.’department_id’ where e.’employee_id’ is null\n右外：select d.*,e.employee_id  from employees e right outer join  department d on d.’department_id’=e.’department_id’ where e.’employee_id’ is null\n3、全外连接（交集+两个表）\nselect bo.,b.  from beauty b ==full oute====r join== boys.bo on b.’boyfriend_id’=bo.id’\n4、交叉连接(乘积连接）\nselect bo.,b.  from beauty b ==full cross join== boys bo\n![img](file:///C:\\Users\\Administrator\\AppData\\Local\\Temp\\ksohtml13072\\wps12.jpg)\n![img](file:///C:\\Users\\Administrator\\AppData\\Local\\Temp\\ksohtml13072\\wps13.jpg)\n子查询\n含义：出现在其他语句中的select语句，称为子查询或内查询\n​            外部的查询称为主查询或外查询\n分类：==按子查询出现的位置==\nselect 后面：仅仅支持标量子查询\nfrom后面：支持表子查询\nwhere或having后面：标量子查询、 列子查询、行子查询\nexists后面–相关子查询：表子查询\n==按结果集行列数不同==       标量子查询（结果集只有一行一列）\n​                                          列子查询（结果集只有一列多行）\n​                                          行子查询（结果集只有一行多列）\n​                                          表子查询（结果集一般为多行多列）\n![img](file:///C:\\Users\\Administrator\\AppData\\Local\\Temp\\ksohtml13072\\wps14.jpg)\n一、where或having后面\n标量子查询（单行子查询）、列子查询（多行子查询）、行子查询（多列多行）\n特点：1、子查询放在小括号内\n​            2、子查询放在条件右侧\n​            3、 ==标量子查询：一般搭配单行操作符使用&lt; 、&gt; 、&lt;=、 &gt;=、=、&lt;&gt;不==\n​                   ==等于==\n列子查询：一般搭配多行操作符使用in、and/some、all\n==子查询的执行优先于主查迅执行，主查迅的条件用到了子查询的结果==\n1、标量子查询\n查询谁的工资比Abel高\n​     #查询Abel工资\nselect salary from employee where last_name = ‘Abel’\n​     #查询员工工资，满足salsry&gt;上述结果\nselect * from employee where salsry&gt;（ select salary from\nEmployee where last_name = ‘Abel’）；\n返回job_id与141号员工相同，salary比143号员工多的员的姓名、job_id和工资\n​     #查询143号员工\nselect salary from employee where job_id =143;\n​    #job_id与141号员工相同,salary比143号员工多的员工的姓名、job_id和工资\nselect last_name、job_id、salary from employee where salsry&gt;(select last_name from employee where employee_id =143) &amp;&amp; job_id = 141;\n返回公司工资最少的员工名字、job_id和salary\n​    #查询工资最低工资\nselect min（salary） from employee ;\n​     #查询员工名字、job_id和salary\nselect last_name,job_id,salsry from employee where salary=( select min（salary） from employee );\n查询最低工资大于50号部门最低工资的部门id和其最低工资\n#50号部门最低工资\nselect min（salary）from employee where department_id =50;\n#查询每个部门的最低工资\nselect min（salary），department_id from employee group by department_id;\n#查询满足最低工资大于50号部门\nselect min（salary），department_id from employee group by department_id having min（salary）&gt;(select min（salary）from employee where department_id =50);\n2、列子查询（多行子查询）\n==操作符：in/not in 等于列表中的任意一个   指一个数列==\n​               ==Any/some 和子查询返回某一个值比较==\n​               ==All 和子查询返回的所有值比较==\n返回location_id是1400或1700的部门中的所有员工姓名\n#查询location_id是1400或1700的部门编号\nselect  department_id from department  where location_id in（1400，1700）\n​    #查询员工姓名，要求部门号是上述列表中的某一个\nselect last_name from employee where department_id in（select  department_id from department  where location_id in（1400，1700））\n返回其他部工种比job_id为‘IT_FROG“工种任意工资低的员工的员工号、姓名、job_id、以及salary\n#查询job_id为‘IT_FROG“部门任意工资\nSelect distinct salary from employee where job_id=“IT_FROG”\n#查询员工号、姓名、job_id、以及salary，salary&lt;上述条件的任\n意一个\nselect last_name ，employee_id ,job_id ,salary from employee where salary &lt; any（Select distinct salary from employee where job_id=“IT_FROG”) and job_id &lt;&gt; ‘IT_PROG’\n3、行子查询（结果集一行多列或多行多列）\n查询员工编号最小并且工资最高的员工信息\n#查询员工编号最小\nselect min（employee_id）  from employee\n#查询工资最高\nSelect max（salary） from employee\n#查询员工信息\nSelect * from employee where employee_id =（select min（employee_id）  from employee ）and salary =（Select max（salary） from employee\n）\n二、放在select后面 （一定要起别名）\n查询每个部门的员工个数\nSelect d.*，(\nSelect count(*)  from employee where e.department_id = d.department_id\n) from department d where employee_id =（select min（employee_id）  from employee ）and salary =（Select max（salary） from employee\n）\n查询员工个号=102的部门名\nSelect (select department_name,e.department_id  from department inner join employee e on d.department_id = e.department_id where e.employee_id = 102)部门名;\n三、from后面，将子查询查到的数据当作表格\n查询每个部门的平均工资的工资等级\n#查询每个部门的平均工资\nSelect avg（salary），department_id from department group by department_id\n​    #查询工资等级\nSelect * from department job_grade\n​    #连接上述结果，筛选条件平均工资 between lowest_sal和highest_sal\nSelec ag_dep.*,g.grade_level\nfrom（\nSelect avg（salary），department_id\nfrom department\ngroup by department_id\n）ag_dep\nInner join job_grade g on ag_dep.ag  between lowest_sal和haighest_sal\n四、exists后面（相关子查询）是否存在，是个布尔类型，1代表true\n==先执行外查询==\n语法：exists（完整查询语句） 结果：1或0\nSelect exists（select employee_id from employees）；有没有值\n查询有员工的部门名\nSelect department_name from departments where exists(select\n* from employee e where d.departmenr_id = e.department_id)\nSelect department_name from departments d where d.’department_id ’ in(select Department_id from employee )\n==标量子查询用=   列子查询用in==\n查询没有女朋友的男神信息\nSelect bo.* from boys bo where bo.id not in(select Boyfriend_id from beauty )\nSelect bo.* from boys bo where not exist(select Boyfriend_id from beauty b where bo.’id’=b.’boyfriend_id’ )\n分页查询*\n应用场景：网站上的第1、2…页，显示不全，不是从服务器全部下载内容，提交sql语句只查询想要页面\n语法：select 查询列表\n​            from 表\n​            【join type join 表2\n​            on 连接条件\n​            where 筛选条件\n​             group by 分组字段\n​             having  分组后的筛选\n​             order by 排序的字段 】\n​             ==limit offset 起始索引（从0开始） size 条目数 ；==\n特点：limit语句在查询语句的最后，执行顺序也在最后\n​            公式：要显示的页数为page 每页的条目数size\n​                       select 查询列表\n​                       from 表\n​                      ==limit offset 起始索引（page-1*size） size 条目数 ；==\n例1 查询前五条员工信息\nselect *from employee limit 0，5；\n从第一条开始也可以写成select *from employee limit 5；\n例2 查询第11条到25条\nselect *from employee limit 10，15；\n例3 查询有奖金的员工信息，并且工资较高前10名显示出来\nselect *from employee where commission_pct is not null order by salary desc limit 0，10；\n联合查询\nunion 联合 合并；将多条查询语句的结果合并为一个结果，大条件拆分\n语法：查询语句1\n​            union\n​            查询语句2\n应用场景：要查询的结果来自于多个表，且没有联系，而查询信息一样，==且查询列数相同====，顺序名一致====，去掉重复项，不想去重则为union all==\n例1 查询部门编号&gt;90，或邮箱中包含A的员工信息\nselect *from employee where email like ‘%a%’ or department_id &gt;90;\nselect *from employee where email like ‘%a%’\nunion\nselect *from employee where department_id &gt;90;\n例2 查询中国用户男性的用户信息以及外国用户男性的用户信息\nselect id，cname，csex from t_ca  where csex = 男；\nunion\nselect t_id , tname , tgender from t_ua employee where tgender = ‘male’；\nDML语言 数据操作语言*\n插入：insert\n修改：update\n删除：delete\n一、插入语句\n语法：表名 列名新值\n​           方式一：\n​            insert into 表名（列名，…）values（值,…);\n​            方式二：\n​            insert into 表名（列名，…）set 列名=值，列名=值;\n两种方式大PK\n1、方式一支持多行，方式二不支持\ninsert into beauty values（13，‘唐艺昕1’，‘女’，‘1990-4-23’，‘12344444’，null，2)，（14，‘唐艺昕2’，‘女’，‘1990-4-23’，‘12344444’，null，2)，（15，‘唐艺昕3’，‘女’，‘1990-4-23’，‘12344444’，null，2)，\n2、方式一支持子查询，方式二不支持\ninsert into beauty（id，name，phone）select（26，‘宋茜’，‘12344444’，null，2);\n==把结果集插进里面==\ninsert into beauty（id，name，phone）select/id，name，‘12344444’（26，‘宋茜’，‘12344444’，null，2)from boys where id&lt;3\n1 插入值的类型和列的类型一致或兼容\ninsert into beauty（id，name，sex，borndate，phone，photo ，boyfriend，boyfriend_id）values（13，‘唐艺昕’，‘女’，‘1990-4-23’，‘12344444’，null，2);\n2 不可以为null的列必须插入值，可以为null的列如何插入值\n方式一 ： insert into beauty（id，name，sex，borndate，phone，photo ，boyfriend，boyfriend_id）values（13，‘唐艺昕’，‘女’，‘1990-4-23’，‘12344444’，null，2);\n方式二： insert into beauty（id，name，sex，borndate，phone，photo ，boyfriend，boyfriend_id）values（13，‘唐艺昕’，‘女’，‘1990-4-23’，‘12344444’，2);\n3 列的顺序是否可以调换，可以要一一对应\n4 列数和值的个数必须匹配\n==5 可以省略列名，默认所有列，而且列的顺序和表的顺序相同==\n二、修改语句\n应用：==修改单表的记录==\n​            语法：update 表名    1\n​                       set 列=新值，列=新值…       3\n​                       where 筛选条件；  2\n​            修改多表的记录【补充】\n​            语法：（192）update 表1 别名，表2 别名\n​                       set 列=新值，列=新值…\n​                       where 连接条件\n​                       and 筛选条件\n​                         （199）update 表1 别名\n​                       inner 、left 、right  join 表2 别名\n​                       on 连接条件\n​                       set 列=新值，列=新值…\n​                       where 筛选条件\n修改单表\n例1 修改beauty姓唐的女生电话修改为12222222\nupdate beauty  set phone=‘122222222’   where name like ‘唐%’；\n例2 修改boy表中id号为2的名称为张飞，魅力值10\nupdate boy  setname=‘张飞’   ，usercp=10；\n修改多表\n例1 修改张无忌女朋友的手机号为114\nupdate boy b inner join beauty be  on b.girl_id = be.girl_id set phone=‘114’  where b.boyname = ‘张无忌’ ;\n例2 修改没有男朋友的女神的男朋友的编号都为2号\nupdate boy b right join beauty be  on b.id = be.boyfriend_id set be.boyfriend_id=‘2’  where b.id is null;\n三、删除语句\n方式一：==delete 删除一列==\n语法：==单表删除==\n​           delete from 表名 where 筛选条件\n​            ==多表删除==\n​           delete（若删除表1内容，则在这里要写表1） 别名 from 表1，别名 ，\n​           表 2，别名 where 连接条件 and 筛选  条件\n方式二：truncate  ==整个表都删除，不能加where条件==\n语法：truncate table 表名；\n方式一\n单表的删除\n例1 删除手机编号为9的女神信息\ndelete from beauty where phone like ’%9‘\n多表的删除\n例1 删除张无忌女朋友的信息\ndelete b from beauty b inner join boys bo on b.boyfriend_id\n= bo .id where bo.boyname = ‘张无忌’\n例2 删除黄晓明以及她女朋友的信息\ndelete b ，bo from beauty b inner join boys bo on b.boyfriend_id\n= bo .id where bo.boyname = ‘黄晓明’\n方式二\n例1 删除魅力值&gt;100的男神信息\ntruncate table boys；\n区别【面试题】\n1、truncate  整个表都删除，不能加where条件，效率高，\n2、假如要删除的表中有自增长列，用delete删除后，再插入数据，自增长列的值从断点开始；用truncate删除后，再插入数据，自增长列的值从1开始；\n3、truncate删除没有返回值  delete删除有返回值，系统提示\n4、truncate删除不能回滚，delete删除能够回滚\n\nDDL语言  数据定义语言\n设计库和表的管理和操作\n一、库的管理\n创建        修改     删除\n二、表的管理\n创建        修改          删除\n创建：create\n修改：alter 修改表和库的结构\n删除：drop 删除表和库\n一、库的管理\n1、库的创建\n语法：creat database 库名\n例1 创建库book （mysql的data文件夹里，重复的库名报错）\ncreate database book；\n提高容错性：create database book if not exists book；\n2、库的修改\n==不能修改库名==\n更改库的字符集：alter database book character set gbk\n3、库的删除\ndrop database if exists book\n二、表的管理\n1、表的创建\n语法： create table 表名{\n​                       列名 列的类型 【（长度)约束 】,\n​                       列名 列的类型 【（长度)约束 】,\n​                       列名 列的类型 【（长度)约束 】,\n​                       …\n}\n例1 创建表book\ncreate table if not exists book{\n​           id int，\n​           bName vachar（20），\n2、表的修改\n修改列名\nalter table book change publishdate==（旧列名）== pubdate ==（新的列名)==  datetime==（类型）==;\n列的类型或约束\nalter table book modify pubdate timestamp==（新类名）==\n添加新列\nalter table author add annual ==（新列名）==double==（类型）==\n删除列\nalter table author drop annual double\n修改表名\nalter table author rename to book_name\n3、表的删除\ndrop table authon；\n查看当前表: show tables\n==创建通用写法==\n==drop database  if exists 旧的库名/表名==\n==create table 新的库名/表名==\n4、表的复制\ninsert into  authon values（1，’村上春树‘，’日本‘）（2，’莫言‘，’中国‘）\n1)仅仅复制表的结构\ncreate table copy like authon\n2）复制表的结构和数据\ncreate table copy2 select*from authon；\n3）只复制部分数据\ncreate table copy3 select id ，name from authon\n4）仅仅复制某些字段 不要数据\ncreate table copy4 select id ，name from authon where 1=2（绝对不成立）\n常见的数据类型\n数值型：\n​               整型\n​               小数：定点数(精度较高)、浮点数\n​               字符型：较短文本——char、varchar\n​                              较长文本——text、blob（较长的二进制数据）\n​               日期型\n一、整型\n分类：tinyint  smallint madiumint  int/integer  bigint\n字节：     1             2              3                    4               8\n1、如何设置无符号和有符号\ncreate table tab_int (\n​         t1 int  加了zerofull 不满的长度会填充为零  ==默认有符号 长度11 可自==\n​    ==己设置== ==但是查询他范围长度== ==输出的是它的字节的那个长度==\n​         t1 int  unsigned   ==默认无符号  长度10== ==可自己设置== ==但是查询他范围长度==\n​         ==输出的是它的字节的那个长度==\n)\n2、插入的数值超出范围后，会报out of range 异常，并且插入临界值\n二、小数\n1、浮点型\ndouble（M,D）\nfloat（M,D）\n2、定点型\ndec(M,D)\ndecimal(M,D)\n特点：\n1、M代表整数部位和小数部位的长度，D代表小数部位，如果超过范围，则    插入临界值\n2、M和D可以省略；==如果是decimal，则M默认为10，D默认为0；如果是float和double，则会随着插入的数值的精度来决定精度==\n3、定点型的精确度较高，如果要求插入的数值精度较高如货币运算等则考虑使用\n原则\n所选择的类型越简单越好，能保存数值的类型越小越好，节省空间\n三、字符型\n较短的文本：\nchar（M）==M可以省略，默认为1==\nvarchar（M）==M不可以省略==\n区别：M代表最大的字符数，char代表固定长度的字符，varchar代表可变长度的字符，char比较耗费空间但效率高\n较长的文本：\ntext\nblob(较大的二进制)\n其他：\nbinary和varbinary用于保存较短的二进制\nenum用于保存枚举\nset用于保存集合\n四、Enum类型 枚举\n要求插入的值必须属于列表中指定的值之一，==不分大小写，但最后也是结果和枚举设定的值一样==\ncreate table tab_char(\n​         t1 enum（‘a’，‘b’，‘c’），\n）；\ninsert into tab_char values（‘A’）\n五、Set类型\n==Set类型一次可以选取多个成员，而enum只能选一个==，根据成本个数不同，存储所占的字节不同\ncreate table tab_char(\n​         t1 enum（‘a’，‘b’，‘c’）\n）；\ninsert into tab_char values（‘A’,‘B’）\n六、日期型\ndate      1000-2-3\ndatetime             1000-2-3  00:00:00\ntimestamp          1000年的某个时刻\ntime         00：00：00\nyear          1000\ndatetime和timestamp区别\n1、datetime取值范围：1000-1-1至9999-12-31；timestamp支持的时间范围小，取值范围：1970 01 01 080001至2038年的某个时间\n2、==datetime只能反映出插入时的当地时区 ，timestamp和实际时区有关，更能反映出实际日期==\n常见的约束\n含义: 一种限制，用于限制表中的数据，为了保证表中数据的准确和可靠性\n例如：李四插入1号，但张三也插入了1号，这就是因为没限制而引起的混乱\n==分类：六大约束==\n​    not null 非空约束，保证该字段的值不能为空，比如姓名、学号\n​    default 默认，用于保证该字段有默认值 ，比如性别\n​    primary  key 主键，用于保证该字段的值有唯一性，==并且非空==，比如学号\n​    unique 唯一约束 ，用于保证该字段有唯一性，==可以为空== 比如座位号\n​    check 检查约束【mysql语法不支持，不报错】比如检查是否性别为男女\n​     foreign key 外键，用于限制两个表的关系，用于保证该字段的值必须来\n​    自主表的关联列的值 ，==保证两个表有联系，在从表添加外键约束，用==\n​     ==于引用主表中某列的值==，比如学生的专业编号\n添加约束的时机\n1、创建表时\n2、修改表时\n3、都在数据添加之前\n约束的添加分类\n1、列级约束：六大约束在语法上都支持，==但外键约束没效果==\n2、表级约束：==除了非空和默认==，其他都支持\ncreate table 表名{\n​       字段名 字段类型  列级约束\n​       字段名 字段类型，\n​        表级约束\n}\n主键和唯一的大对比\n​              保证唯一性     是否为空          一个表中可以有多少个  是否允许组合\n主键       ke                                                    至多有一个                    ke\n唯一        ke\t\t\t\t\t\tke                       可以有多个                    ke\n外键特点\n1、要求在从表设置外键关系\n2、从表外键列类型和主表的关联列的类型要求一致或兼容，名称无所谓\n3、要求主表的关联列必须是一个key（一般是主键或唯一键）\n4、插入数据，先插入主表，再插入从表\n​      删除数据，想删除从表，在删除主表\n一、创建表时添加约束\n1、添加列级约束\n（sex有别的意思，可用gender代表性别）\n==语法：直接在字段名和类型后面追加约束类型，只支持默认、非空、主键、唯一====，可以插入多个约束可以用空格隔开==\ncreate database stunifo(\n​       id int primary key ，\n​        stuname varchar（20）not null  ==unique  default==，\n​        gender char（1）check（gender =‘男’ or gender=‘女’），\n​        seat int unique， \n​         age int default ，\n​         ==majorid int foreign key reference major（id），==\n)\ncreate database stunifo(\n​       id int primary key， \n​        stuname varchar（20）not null ，\n）\n==通过desc  库名查看表的结构，可查看非空、键、默认==\n==通过show index  from  库名查看表中所有的索引，包括主键、外键、唯一==\n2、添加表级约束\n==语法：在各个字段的最下边==\n==【constraint  约束名 】可省略约束类型 （字段名）==\ncreate database stunifo(\n​       id int ，\n​        stuname varchar（20），\n​        gender char（1），\n​        seat int，\n​         age int ，\n​         majorid int ，\n​         constraint pk（约束名）==primary key约束类型（id）==，为id添加主键\n​         ==主键名默认为primary==\n​         constraint uk（约束名）==unique约束类型（seat）==，为seat添加唯一键\n​         constraint ==ppk foreign key（majorid） reference major（id），==\n)\n==通用的写法：creat primary 、unique放在列级约束，主键放在表级约束==\ncreate database stunifo(\n​       id int primary key ，\n​        stuname varchar（20）not null ，\n​        gender char（1），\n​        seat int unique， \n​         age int default ，\n​         majorid int ，\n​          constraint ==ppk foreign key（majorid） reference   ==\n​         ==major（id），==\n)\n二、修改表时添加约束\n特点：\n1、添加列级约束\nalter table 表名 MODIFY COLUMN 字段名 字段类型 新约束\n2、添加表级约束\nalter table 表名 add 【constraint 约束名】约束类型（字段名) 【外键的引用】\ncreate database stunifo(\n​       id int primary key ，\n​        stuname varchar（20）not null  ==unique  default==，\n​        gender char（1）check（gender =‘男’ or gender=‘女’），\n​        seat int unique， \n​         age int default ，\n​         ==majorid int foreign key reference major（id），==\n)\n1、添加非空约束\nalter table stunifo MODIFY COLUMN stuname（添加约束的表名）\nvarchar（20）not null （对应的约束）\n2、添加默认约束\nalter table stunifo MODIFY COLUMN age（添加约束的表名）int default 18（对应的约束）\n3、添加主键\n列级约束alter table stunifo MODIFY COLUMN id int primary key\n表级约束alter table stunifo add primary key（id）\n4、添加唯一键\n列级约束alter table stunifo MODIFY COLUMN seat int unique\n表级约束alter table stunifo add unique（seat）\n5、添加外键\n表级约束alter table stunifo add FOREIGN KEY（majorid）reference major（id)\n三、修改表时删除约束\n1、删除非空约束\nalter table stunifo MODIFY COLUMN stuname（添加约束的表名）\nvarchar（20）\n2、删除默认约束\nalter table stunifo MODIFY COLUMN **age（添加约束的表名）int **\n3、删除主键\nalter table stunifo**drop primary key  **\n4、删除唯一键\nalter table stunifo drop index seat\n5、删除外键\n表级约束alter table stunifo drop FOREIGN KEY majorid\n","plink":"http://example.com/2021/03/16/数据库/"},{"title":"Hello World","date":"2021-02-02T09:59:38.499Z","date_formatted":{"ll":"2021年2月2日","L":"2021/02/02","MM-DD":"02-02"},"updated":"2021-02-07T09:53:46.166Z","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n\nQuick Start\nCreate a new post\n1$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server\n1$ hexo server\nMore info: Server\nGenerate static files\n1$ hexo generate\nMore info: Generating\nDeploy to remote sites\n1$ hexo deploy\nMore info: Deployment\n","plink":"http://example.com/2021/02/02/hello-world/"}]