[{"title":"多线程","date":"2021-05-22T13:29:16.000Z","date_formatted":{"ll":"2021年5月22日","L":"2021/05/22","MM-DD":"05-22"},"updated":"2021-05-22T14:09:05.644Z","content":"1、概念\n多任务\n边吃饭边看手机，看起来是多个任务，但在同一时间里只做了一件事情\n多线程\n原来只有一条车道，慢慢因为车多了，道路堵塞，效率降低，因此开辟了一条道路\n普通方法和多线程\n\n进程(process)和线程(Thread)关系\n==一个进程可以有多个线程，==如视频中同时听到声音，看到图片，看弹幕等。==一个进程至少有一个线程，线程是CPU调度和执行的单位==\n很多多线程是模拟出来的，==真正的多线程是多个CPU，即多核，如服务器==\n==程序==：是指令和数据的有序集合，其本身没有，任何运行的含义，是一个==静态==的概念\n==进程==：是执行程序的一次执行过程，是一个==动态的概念，是系统资源分配==的单位\n核心\n1、线程是==独立的执行路径==\n2、在程序运行时，后台会有==多个路径，如主线程和gc线程==（即垃圾回收进程）\n3、==main（）称之为主线程，为系统的入口==，用于执行整个程序\n4、在一个进程中，如果开辟了多个线程，==线程的运行由调度器安排，调度器与操作系统相关，先后顺序是不能人为的干预的==\n5、对同一份资源操作时，会==存在资源抢夺问题，需要加入并发控制==\n6、==线程会带来额外的开销==，如Cpu调度时间，并发控制开销\n7、每个线程在自己的工作内存交互，==内存控制不当会造成数据不一致==\n2、线程的创建\nThread class    继承Thread类（重点）-------API\nRunnable 实现Runnable接口（重点）\nCallable  实现Callable接口（了解）\nThread class\n==继承Thread类，重写run方法，创建对象，调用start（）==方法启动\n==start（）使得交替执行，没有先后顺序==\nRunnable\n==一个类继承该接口，重写run方法，创建该类的对象，将Thread实例化并赋给它，再用start==\nThread方法\n1public static Thread currentThread()\n返回对当前正在执行的线程对象的引用。\n12public static void sleep(long millis)                  throws InterruptedException\n使当前正在执行的线程以指定的毫秒数暂停(暂时停止执行)，具体取决于系统定时器和调度程序的精度和准确性。 线程不会丢失任何显示器的所有权。\n小结\nThread：1、子类继承Thread类具备多线程能力\n​                 2、启动线程：子类对象.start()\n​                 3、==不建议：避免OOP单继承局限性==\nRunnable：1、实现Runnable具有多线程能力\n​                     2、启动线程：传入目标对象+Thread对象.start()\n​                     3、推荐：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用\n实现Callable接口（了解）\n1、==实现Callable接口==，需要返回值类型\n2、==重写call方法==，需要抛出异常\n3、创建目标对象\n4、创建执行服务  ExecutorService ser=Executors.newFixedThreadPool(线程个数);\n5、提交执行：Futureresult1=ser.submit(线程名称)\n6、获取结果：boolean r=result1.get()\n7、关闭服务：ser.shutdownNow();\n!\nCallable好处\n1、可以定义为返回值\n2、可以抛出异常\n静态代理（进程的实现原理）\n你：真实角色\n婚庆公司：代理你，帮你处理结婚的事情\n结婚：实现结婚的接口\n总结\n真实对象和代理对象都要实现同一个接口，代理对象要先代理真实角色\n好处\n代理对象可以实现很多真实对象做不了的事情\n真实对象专注做自己的事情\nLamda表达式-\n定义：\n==任何接口，如果只包含唯一一个抽象方法==，那么他就是一个函数式接口\n12345public interface Runable&#123;     public abstract void run（）；&#125;\n对于函数式接口，我们可以通过lamda表达式来创建该接口的对象\n==最普通 静态内部类 局部内部类  匿名内部类  拉姆达类==\n好处\n避免匿名内部类定义过多\n其实质属于函数式编程的概念\n对象=()-&gt;{…}\n==带有参数==\n1、直接代入\n2、参数类型删去\n3、删去括号\n4、删去花括号，==但只能是一条语句==(以上可以一起执行)\n5、==有多个参数类型。去掉参数，用逗号隔开且用括号括====起来==\n3、线程状态\n!\n1000毫秒=1秒\n停止线程\n1、推荐线程自己停止下来\n2、建议使用一个标志位进行终止变量，当flag=false，则终止线程运行\n3、不推荐使用JDK提供的stop()、destroy()方法\n步骤\n1、设置标识符\n2、设置一个公开方法停止线程，转换标识符\n3、调用stop方法切换标识符，让线程停止\n1234567891011121314151617181920212223242526272829package stop;public class One implements Runnable&#123;\tprivate boolean flag&#x3D;false;\tpublic void run()&#123;\t    int i&#x3D;0;\t\twhile(flag)&#123;\t\t\tSystem.out.println(&quot;run&quot;+i);\t\t&#125;\t&#125;\t&#x2F;&#x2F;设置一个方法让线程停止\tpublic void stop()&#123;\t\tthis.flag&#x3D;true;\t&#125;\tpublic static void main(String[]args)&#123;\t\tOne o&#x3D;new One();\t\tnew Thread(o).start();\t\tfor(int i&#x3D;0;i&lt;2000;i++)&#123;\t\t\tSystem.out.println(&quot;mmm&quot;+i);\t\t\tif(i&#x3D;&#x3D;1000)&#123;\t\t\t&#x2F;&#x2F;调用stop方法切换标志位，让线程停止\t\t\t\to.stop();\t\t\t\tSystem.out.println(&quot;线程停止了&quot;);\t\t\t&#125;\t\t&#125;\t&#125;\t&#125;\n线程休眠sleep\n1、sleep指定当前线程阻塞的毫秒数\n2、sleep存在异常interruptedException\n3、sleep时间达到后线程进入就绪状态\n4、sleep可以模拟网络延时、倒计时\n5、每一对象都有一把锁，sleep不会释放锁\n12345678910111213141516171819202122232425package baobie;public class 线程睡眠 &#123;\tpublic static void main(String[]args)&#123;\t\ttry&#123;\t\t\ttime();\t\t&#125;\t\tcatch(InterruptedException e)&#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;\tpublic static void time() throws InterruptedException&#123;\t\tint rum&#x3D;10;\t\twhile(true)&#123;\t\t\tThread.sleep(1000);\t\t\tSystem.out.println(rum--);\t\t\tif(rum&lt;&#x3D;0)&#123;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n线程礼让yield\n1、礼让线程，让当前正在执行的线程暂停，但不阻塞\n2、将线程从运行状态变为就绪状态\n3、让cpu重新调度，礼让不一定成功，看CPU心情\n123456789101112131415161718package baobie;public class 线程yield &#123;\tpublic static void main(String[] args) &#123;\t\tmyYield t&#x3D;new myYield();\t\tnew Thread(t,&quot;小明&quot;).start();\t\tnew Thread(t,&quot;小黑&quot;).start();\t&#125;&#125;class myYield implements Runnable&#123;\t\tpublic void run()&#123;\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;开始执行&quot;);\t\t\tThread.yield();\t\t\tSystem.out.println(Thread.currentThread().getName()+&quot;停止执行&quot;);\t&#125;\t&#125;\n线程合并join\n1、join合并线程，待此线程执行完成后，在执行其他线程，其他线程阻塞\n2、可以想象成插队，执行完插队的内容，在执行主线程\n123456789101112131415161718192021222324package baobie;public class 线程join &#123;\tpublic static void main(String[] args) throws InterruptedException &#123;\t\tjoins a&#x3D;new joins();\t\tThread b&#x3D;new Thread(a);\t\tb.start();\t\t\t\tfor(int j&#x3D;0;j&lt;400;j++)&#123;\t\t\tif(j&#x3D;&#x3D;100)&#123;\t\t\t   b.join();\t\t\t&#125;\t\t\tSystem.out.println(&quot;main&quot;+j);\t\t&#125;\t&#125;&#125;class joins implements Runnable&#123;\tpublic void run()&#123;\t\tfor(int i&#x3D;0;i&lt;1000;i++)&#123;\t\t   System.out.println(&quot;线程VIP来了&quot;+i);\t\t&#125;\t&#125;\n线程状态监测\nNEW 尚未启动线程\nRUNNABLE 在Java虚拟机执行的线程处于此状态\nBLOOKED 被阻塞\nWAITING  正在等待另一个线程执行特定的动作处于此状态\nTIMED WAITING 正在等待另一个执行动作达到指定等待时间的线程处于此状态\nTERMINATED\n已退出的线程\n线程优先级\n1、Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行\n2、线程的优先级用数字来表示，范围1到10\nThread.MIN_PRIORITY=1\nThread.MAX_PRIORITY=10\nThread.NORN_PRIORITY=5\n3、使用以下方式改变或获取优先级\ngetPority setPriority(int xxx)\n4、从数字高的先执行（但还是得看CPU调度）\n1234567891011121314151617181920212223242526272829303132333435363738package baobie;public class 线程优先级 &#123;\tpublic static void main(String[] args)&#123;\t\tSystem.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+Thread.currentThread().getPriority());\t\t&#x2F;&#x2F;main方法默认为5\t\tmyPriority n&#x3D;new myPriority();\t\tThread t1&#x3D;new Thread(n);\t\tThread t2&#x3D;new Thread(n);\t\tThread t3&#x3D;new Thread(n);\t\tThread t4&#x3D;new Thread(n);\t\tThread t5&#x3D;new Thread(n);\t\tThread t6&#x3D;new Thread(n);\t\t\t\tt1.start();&#x2F;&#x2F;默认\t\t\t\tt2.setPriority(1); \t\tt2.start();\t\t\t\tt3.setPriority(4);\t\tt3.start();\t\t\t\tt4.setPriority(9);\t\tt4.start();\t\tt5.setPriority(-1);\t\tt5.start();\t&#x2F;&#x2F;\tt6.setPriority(11);\t&#x2F;&#x2F;\tt6.start();\t&#125;&#125;class myPriority implements Runnable&#123;\tpublic void run()&#123;\t\tSystem.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+Thread.currentThread().getPriority());\t&#125;&#125;\n守护(daemon)线程\n1、线程分为用户线程和守护线程\n2、虚拟机必须确保用户线程执行完毕 main\n3、虚拟机不用等待守护线程执行完毕   gc\n4、true为用户线程 false为守护线程\n如：后台记录操作日志，监控内存，垃圾回收\n12345678910111213141516171819202122232425262728293031323334package baobie;public class 守护线程 &#123;\tpublic static void main(String[] args)&#123;\t\tGod g&#x3D;new God();\t\tuser u&#x3D;new user();\t\t\t\tThread t&#x3D;new Thread(g);\t\tt.setDaemon(true);&#x2F;&#x2F;true为守护线程\t\tt.start();&#x2F;&#x2F;守护线程启动\t\t&#x2F;&#x2F;new Thread(u).start();&#x2F;&#x2F;用户线程\t\tThread k&#x3D;new Thread(u);\t\tk.setDaemon(false);&#x2F;&#x2F;默认为false 则是用户线程 正常的线程都是用户线程\t\tk.start();&#x2F;&#x2F;用户线程启动\t&#125; &#125;\t&#x2F;&#x2F;守护线程\tclass God implements Runnable&#123;\t\tpublic void run()&#123;\t\t\twhile(true)&#123;\t\t\t\tSystem.out.println(&quot;上帝保佑你&quot;);\t\t\t&#125;\t\t&#125;\t&#125;\t&#x2F;&#x2F;用户线程\tclass user implements Runnable&#123;\t\tpublic void run()&#123;\t\t\tfor(int i&#x3D;0;i&lt;20;i++)&#123;\t\t\t\tSystem.out.println(&quot;好人一生平安&quot;+i);&#x2F;&#x2F;用户线程必须执行完毕\t\t\t&#125;\t\tSystem.out.println(&quot;Good byb&quot;);\t\t&#125;\t&#125;\n4、线程同步机制\n==并发：同一个对象被多个线程同时操作==  例如：两个银行同时取钱\n现实生活中，遇到同一个戏院多个人想同时使用，比如食堂排队，每个人先吃饭，最简单的方式:排队\n处理多个线程问题，多个线程访问同一个对象时，并且某些线程还想修改这个对象，这时候我们就需要线程同步，线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程在使用\n形成条件：队列+==锁==\n由于同一进程的多个线程同时共享同一块存储空间，在带来方便的同时，也也带来访问冲突问题。为了保证数据在方法中被访问时的正确性，在访问时加入锁机制 ==synchronized== ，当一个线程获得对象的锁。独占资源。其他线程笔其他对象必须等待，使用后释放锁即可，但存在以下问题：\n1、一个线程持有索会导致其他所有需要此锁的线程挂起\n2、在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延迟，引起性能问题\n3、如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题。比如：上大号和小号，性能低大号上厕所，小号性能高会等待的久\n同步synchronized\nsynchronized方法和synchronized块\n同步方法\npublic synchronized void method(int  args){ }\nsynchronized方法控制对象的访问，每个对象对应一把锁，每个==synchronized==**方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞。方法一旦调用，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程。**缺陷：==将一个大的方法声明为synchronized将会影响效率==\n同步块\nsynchronized（Obj）{}\n==Obj称为同步监视器，锁变化的量==\n**Obi可以是任何对象，**但是推荐使用共享资源作为同步监视器\n同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class【反射中讲解】\n同步监视器的执行过程：\n1、第一个线程访问，锁定同步监视器，执行其中代码\n2、第二个线程访问，发现同步监视器被锁定，无法访问\n3、第一个线程访问，解锁同步监视器\n4、第二个线程访问，发现同步监视器没有被锁定，然后锁定并访问\njuc安全集合\n==CopyOnWriteArrayList==所建立的对象是安全的\n5、死锁\n多个线程各自站有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，==某一个同步块同时拥有”两个以上对象的锁“时，就可能会发生”死锁“问题==\n例如：拿了这个锁，但还想要另一个所，但一个人只能有一个锁\n产生死锁的四个必要条件\n1、互斥条件：一个资源每次只能被一个进程使用\n2、请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放\n3、不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺、\n4、循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系\n==只要想办法破其中的任意一个或多个条件就可以避免死锁发生==\n6、Lock锁\n1、通过显示定义同步锁对象来实现同步，同步锁使用了Lock对象充当\n2、java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具，锁提供了对共享资源空间的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享对象之前先获的Lock对象\n3、ReentrantLock类实现Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的时ReentrantLock，可以显示加锁、释放锁\n12345678910111213class A&#123;   private final ReentrantLock lock&#x3D;new ReentratrLock();   public void m()&#123;   \t lock.lock();     try&#123;          &#125;     finally&#123;       lock.unlock();       &#x2F;&#x2F;如果同步代码块有异常，将unlock（）写入finally语句块     &#125;   &#125;&#125;\nSynchronized和Lock的对比\n==1、Lock是显示锁(手动开启和关闭锁)，synchronized是隐式锁，出了作用域自动释放==\n2、Lock只有代码块锁，synchronized有代码块锁和方法锁\n3、使用Lock锁，JVM将花费较少的时间调度线程，性能更好，并且具有更好的拓展性\n优先使用顺序：Lock&gt;同步代码块（已经进入了方法体，分配了相应资源）&gt;同步方法(在方法体之外)\n7、线程通信\n分析：这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件\n1、对于生产者，没有生产产品之前，要通知消费者等待，而生产了产品之后，又需要马上通知消费者消费\n2、对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费\n==3、在生产者消费者问题中，仅有synchronized是不够的==\n​      ==synchronized可阻止并发更新同一个共享资源，实现了同步==\n​      ==synchronized不能用来实现不同线程之间的消息传递(通信)==\n方法\nwait() 表示线程会一直等待，知道其他线程通知，与sleep不同，会释放锁\nwait(long times)指定等待的毫秒数\nnotify() 唤醒一个处于等待状态的线程\nnotifyAll() 唤醒同一个对象上所有调用wait() 方法的线程，优先级别高的线程优先调查\n均为Object类的方法，==都只能在同步方法或者同步代码块中使用==，否则会抛出异常IllegalMonitorStateException\n解决\n（1）并发协作模型”生产者/消费者模式“-&gt;管程法\n生产者：负责生产数据的模块(可能是方法，对象，线程，进程)\n消费者：负责处理数据的模块(可能是方法，对象，线程，进程)\n缓冲区：消费者不能直接使用生产者的数据，它们之间有个”缓冲区“\n==生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据==\n（2）并发协作模型”生产者/消费者模式“-&gt;信号灯法\n类似于”停止线程“\n注意\nsleep（） wait（）有try catch\n8、线程池\n背景：经常创建和销毁，使用量特别大，比如出现并发情况下的线程，对性能影响很大\n思路：提前创建好多个线程，放入线程池中，使用是直接获取，使用完放回池子中，可以避免频繁创建销毁、实现重复利用，类似交通工具\n好处：提高响应速度，降低资源耗损，便于线程管理\n方法：corePoolSize：核心池的大小\n​            maximumPoolSize：最大线程数\n​             keepAliveTime：线程没有任务时最多保持多长时间会终止\nExecutorService：真正线程池接口\n​                                 常见子类；void excute(Runnable command)——执\n​                                                    行命令，没有返回值\n​\t\t\t\t\t\t\t\t\t\t\t\t\tFuturesubmit(Callabletask)——\n​                                                    执行命令，有返回值\n​                                                    void  shutdown()——关闭连接池\nExecutors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池\n","plink":"http://example.com/2021/05/22/多线程/"},{"title":"Hello World","date":"2021-02-02T09:59:38.499Z","date_formatted":{"ll":"2021年2月2日","L":"2021/02/02","MM-DD":"02-02"},"updated":"2021-02-07T09:53:46.166Z","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n\nQuick Start\nCreate a new post\n1$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server\n1$ hexo server\nMore info: Server\nGenerate static files\n1$ hexo generate\nMore info: Generating\nDeploy to remote sites\n1$ hexo deploy\nMore info: Deployment\n","plink":"http://example.com/2021/02/02/hello-world/"}]